#!/usr/bin/awk -f

# generated by smpg.awk 1.0

# <description>
function DESCRIPT() {
return \
"included files:\n"\
"_check.awk\n"\
"_misc.awk\n"\
"_rdpg_pft.awk\n"\
"_generate.awk\n"\
"_doc.awk\n"\
"_rdpg_ir.awk\n"\
"awklib_prog.awk\n"\
"awklib_array.awk\n"\
"awklib_vect.awk\n"\
"awklib_tabs.awk\n"\
"awklib_prefix_tree.awk\n"\
"\n"\
"fsm rules:\n"\
"rule -> defn\n"\
"defn -> defn | goal | fail | end\n"\
"goal -> defn | fail | end\n"\
"fail -> end\n"\
"end -> rule\n"\
"\n"\
"'->' is read as 'must be followed by'\n"\
"'|' is read as 'or'"
}
# </description>

# <other>
# Author: Vladimir Dinev
# vld.dinev@gmail.com
# 2021-10-12

function SCRIPT_NAME() {return "rdpg.awk"}
function SCRIPT_VERSION() {return "1.31"}

# <awk_rules>
function init() {
	set_program_name(SCRIPT_NAME())

	if (Help)
		print_help()
	if (Version)
		print_version()
	if (Example)
		print_example()
	if (ARGC != 2)
		print_use_try()
	Strict = (Strict) ? Strict : ""
	
	# G_tree has to be a global variable
	rdpg_pft_init(G_tree)
}
BEGIN {
	init()
}
END {
	if (!did_error_happen() && !should_skip_end()) {
		perform_input_checks(G_tree)
		generate_ir(G_tree)
	}
}
/^[[:space:]]*(#|$)/ {next} # ignore empty lines and comments
{fsm_next(G_the_fsm, $1)}
# </awk_rules>

function error_qfpos(msg) {
	error_quit(sprintf("file '%s' line %d: %s", FILENAME, FNR, msg))
}
# </other>

# <templated>
# 'rule|defn'
function rule_save(str) {vect_push(_B_vect_rule, str)}
function rule_get(n) {return _B_vect_rule[n]}
function rule_get_count() {return vect_len(_B_vect_rule)}

function defn_save(str) {vect_push(_B_vect_defn, str)}
function defn_get(n) {return _B_vect_defn[n]}
function defn_get_count() {return vect_len(_B_vect_defn)}

# 'goal|fail'
function goal_add(path, val) {_B_map_goal[path] = val}
function goal_get(path) {return _B_map_goal[path]}

function fail_add(path, val) {_B_map_fail[path] = val}
function fail_get(path) {return _B_map_fail[path]}
# </templated>

# <fsm>
# <handlers>
function fsm_on_rule(    _rule) {
	data_or_err()
	
	_rule = remove_first_field($0)
	syntax_check_rule(_rule)
	_rule = rule_process_name(_rule)
	
	save_raw_definition(_rule, $0)
	
	if (rule_set_has(_rule))
		error_qfpos(sprintf("rule '%s' redefined", _rule))
	else
		rule_set_place(_rule)
		
	rule_line_map_save(_rule)
	rule_save(_rule)
}
function fsm_on_defn(    _rule, _defn, _full_path) {
	data_or_err()
	
	gsub("^\"|\"$", "", $0)
	_rule = get_current_rule()
	save_raw_definition(_rule, $0)
	
	_defn = remove_first_field($0)
	_defn = syntax_check_defn(_defn)
	_full_path = get_full_path(_rule, _defn)
	
	defn_save(_full_path)
	add_defn_to_rule(G_tree, _rule, _defn)
}
function fsm_on_goal() {
	data_or_err()
	goal_add(get_current_defn(), remove_first_field($0))
}
function fsm_on_fail() {
	data_or_err()
	fail_add(get_current_rule(), remove_first_field($0))
}
function fsm_on_end() {
	# nothing to do
}
function fsm_on_error(curr_st, expected, got) {
	error_qfpos(sprintf("'%s' expected, but got '%s' instead", expected, got))
}
# </handlers>

# <constants>
function FSM_RULE() {return "rule"}
function FSM_DEFN() {return "defn"}
function FSM_GOAL() {return "goal"}
function FSM_FAIL() {return "fail"}
function FSM_END() {return "end"}
function _FSM_STATE() {return "state"}
# </constants>

# <functions>
function fsm_get_state(fsm) {return fsm[_FSM_STATE()]}
function _fsm_set_state(fsm, next_st) {fsm[_FSM_STATE()] = next_st}
function fsm_next(fsm, next_st,    _st) {

	_st = fsm_get_state(fsm)
	if ("" == _st) {
		if (FSM_RULE() == next_st)
		{fsm_on_rule(); _fsm_set_state(fsm, next_st)}
		else
		{fsm_on_error(_st, FSM_RULE(), next_st)}
	}
	else if (FSM_RULE() == _st) {
		if (FSM_DEFN() == next_st)
		{fsm_on_defn(); _fsm_set_state(fsm, next_st)}
		else
		{fsm_on_error(_st, FSM_DEFN(), next_st)}
	}
	else if (FSM_DEFN() == _st) {
		if (FSM_DEFN() == next_st)
		{fsm_on_defn(); _fsm_set_state(fsm, next_st)}
		else if (FSM_GOAL() == next_st)
		{fsm_on_goal(); _fsm_set_state(fsm, next_st)}
		else if (FSM_FAIL() == next_st)
		{fsm_on_fail(); _fsm_set_state(fsm, next_st)}
		else if (FSM_END() == next_st)
		{fsm_on_end(); _fsm_set_state(fsm, next_st)}
		else
		{fsm_on_error(_st, FSM_DEFN()"|"FSM_GOAL()"|"FSM_FAIL()"|"FSM_END(), next_st)}
	}
	else if (FSM_GOAL() == _st) {
		if (FSM_DEFN() == next_st)
		{fsm_on_defn(); _fsm_set_state(fsm, next_st)}
		else if (FSM_FAIL() == next_st)
		{fsm_on_fail(); _fsm_set_state(fsm, next_st)}
		else if (FSM_END() == next_st)
		{fsm_on_end(); _fsm_set_state(fsm, next_st)}
		else
		{fsm_on_error(_st, FSM_DEFN()"|"FSM_FAIL()"|"FSM_END(), next_st)}
	}
	else if (FSM_FAIL() == _st) {
		if (FSM_END() == next_st)
		{fsm_on_end(); _fsm_set_state(fsm, next_st)}
		else
		{fsm_on_error(_st, FSM_END(), next_st)}
	}
	else if (FSM_END() == _st) {
		if (FSM_RULE() == next_st)
		{fsm_on_rule(); _fsm_set_state(fsm, next_st)}
		else
		{fsm_on_error(_st, FSM_RULE(), next_st)}
	}
}
# </functions>
# </fsm>

# <includes>
# ./_check.awk
# <check>
function perform_input_checks(tree) {
	if (Strict)
		check_undefined_rules(tree)
	check_reachability(tree)
	check_left_recursion(tree)
}
# <check_left_recursion>
function left_rec_seen_reset() {_B_left_rec_set[""]; delete _B_left_rec_set}
function left_rec_was_seen(symb) {return _B_left_rec_set[symb] }
function left_rec_mark(symb) {_B_left_rec_set[symb] = 1}
function check_left_rec_rule(tree, rule,
    _next, _prev, _val, _arr, _len, _i, _trace) {
	
	if (!_next) {
		# first time; reset symbols, start from rule
		left_rec_seen_reset()
		_next = rule
	}
	
	if (!rdpg_pft_has(tree, _next)) {
		# guard against non-existent rule
		return ""
	}
	
	if (left_rec_was_seen(_next)) {
		# _next has already been considered and did not result in an error
		return ""
	} else {
		# _next has not been considered, needs a check
		left_rec_mark(_next)
	}
	
	if (!_prev) {
		# first time; begin the trace path with the top rule
		_prev = _next
	} else {
		# not first time; add _next to the trace path
		_prev = sprintf("%s -> %s", _prev, _next)
	}
	
	_val = rdpg_pft_get(tree, _next)
	_len = rdpg_pft_split(_val, _arr)
	
	if (rdpg_pft_arr_has(_arr, _len, rule)) {
		# if the top rule exists in any of its own leftmost derivations, or
		# in any of the leftmost derivations of its leftmost derivations
		# return the trace
		return sprintf("%s -> %s", _prev, _val)
	}
	
	for (_i = 1; _i <= _len; ++_i) {
		if (_trace = check_left_rec_rule(tree, rule, _arr[_i], _prev)) {
			# if a non-empty trace has occurred, we have leftmost recursion
			return _trace
		}
	}
}
function print_left_rec(rule, trace) {
	chk_err_fpos(rule_line_map_get(rule), rule,
		sprintf("left recursion: %s", trace))
}
function check_left_recursion(tree,    _rule, _i, _end, _trace, _err) {
	_err = 0
	_end = rule_get_count()
	
	for (_i = 1; _i <= _end; ++_i) {
		_rule = rule_get(_i)
		
		if (_trace = check_left_rec_rule(tree, _rule)) {
			_err = 1
			print_left_rec(_rule, _trace)
		}
	}
	
	if (_err)
		exit_failure()
}
# </check_left_recursion>

# <check_reachability>
function check_reachability_rule(tree, rule, _root,    _val, _path, _err) {
	
	if (!_root)
		_root = rule
	
	if (!_err)
		_err = 0
	
	if (!rdpg_pft_has(tree, _root))
		return
	
	_val = rdpg_pft_get(tree, _root)
	_path = rdpg_pft_cat(_root, _val)
	
	if (_val && rdpg_pft_is_marked(tree, _root)) {
		
		chk_err_fpos(rule_line_map_get(rule), rule, "ambiguity detected")
		
		gsub(("\\" RDPG_PFT_SEP()), " -> ", _path)
		pstderr(sprintf("'%s'", _path))
		gsub(("\\" RDPG_PFT_SEP()), " -> ", _root)
		pstderr(sprintf("'%s'", _root))
		
		_err = 1
	}
	
	return _err + check_reachability_rule(tree, rule, _path)
}

function check_reachability(tree,    _rule, _i, _end, _err) {
	_err = 0
	_end = rule_get_count()
	
	for (_i = 1; _i <= _end; ++_i) {
		_rule = rule_get(_i)
		_err = check_reachability_rule(tree, _rule)
	}
	
	if (_err)
		exit_failure()
}
# </check_reachability>

# <check_undefined_rules>
function check_undefined_rule(tree, rule,    _root, _i, _val, _arr_val,
_len_val, _symb, _err) {
	
	if (!_err)
		_err = 0
	
	if (!_root)
		_root = rule

	if (!rdpg_pft_has(tree, _root))
		return 0
	
	_val = rdpg_pft_get(tree, _root)
	_len_val = rdpg_pft_split(_val, _arr_val)
	
	for (_i = 1; _i <= _len_val; ++_i) {
		_symb = _arr_val[_i]
		
		if (!is_terminal(_symb) && !is_a_rule(_symb)) {
			chk_err_fpos(rule_line_map_get(rule), rule,
				sprintf("call to an undefined rule '%s'", _symb))
			_err = 1
		}
		
		_err += check_undefined_rule(tree, rule, rdpg_pft_cat(_root, _symb))
	}
	
	return _err
}

function chk_err_fpos(line, rule, msg) {
	error_print(sprintf("file '%s', line %d, rule '%s': %s",
		FILENAME, line, rule, msg))
}

function check_undefined_rules(tree,    _rule, _i, _end, _err) {
	_err = 0
	_end = rule_get_count()
	
	for (_i = 1; _i <= _end; ++_i) {
		_rule = rule_get(_i)
		_err += check_undefined_rule(tree, _rule)
	}
	
	if (_err)
		exit_failure()
}
# </check_undefined_rules>
# </check>
# ./_misc.awk
# <misc>
function data_or_err() {
	if (NF < 2)
		error_qfpos(sprintf("no data after '%s'", $1))
}

function NULLABLE() {return "?"}
function get_last_ch(str) {return substr(str, length(str))}
function remove_last_ch(str) {return substr(str, 1, length(str)-1)}
function remove_first_field(str) {
	sub("[^[:space:]]+[[:space:]]*", "", str)
	return str
}

function save_raw_definition(rule, defn, _str) {
	_str = _B_plain_defn[rule]
	_str = sprintf("%s%s\n", _str, defn)
	_B_plain_defn[rule] = _str
}
function get_raw_definition(rule) {return _B_plain_defn[rule]}

function null_set_place(rule) {_B_null_set[rule] = 1}
function null_set_has(rule) {return _B_null_set[rule]}
function is_rule_nullable(rule) {return null_set_has(rule)}
function rule_set_place(rule) {_B_rule_set[rule] = 1}
function rule_set_has(rule) {return _B_rule_set[rule]}
function rule_line_map_save(rule) {_B_rule_line[rule] = FNR}
function rule_line_map_get(rule) {return _B_rule_line[rule]}
function is_a_rule(str){return rule_line_map_get(str)}
function get_current_rule() {return rule_get(rule_get_count())}
function is_terminal(str) {
	return match(str, "^[_[:upper:]][[:upper:][:digit:]_]*$")
}

function RE_NON_TERMINAL() {return "^[_[:lower:]][[:lower:][:digit:]_]*\\??$"}
function is_non_terminal(symb) {
	return match(symb, RE_NON_TERMINAL())
}
function rule_process_name(rule,    _rule) {
	_rule = rule
	
	if ((get_last_ch(_rule) == NULLABLE())) {
		_rule = remove_last_ch(_rule)
		null_set_place(_rule)
	}
	return _rule
}

function add_defn_to_rule(tree, rule, defn) {
	rdpg_pft_insert(tree, rule, defn)
}
function get_full_path(rule, defn,    _full_path) {
	_full_path = (rule " " defn)
	gsub("[[:space:]]+", RDPG_PFT_SEP(), _full_path)
	return _full_path
}
function get_current_defn() {return defn_get(defn_get_count())}

function syntax_check_rule(rule) {
	if (!is_non_terminal(rule)) {
		error_qfpos(sprintf("bad rule syntax '%s'; has to match '%s'",
			rule, RE_NON_TERMINAL()))
	}
}

function syntax_check_defn(str,    _i, _len, _arr, _tmp) {
	_len = split(str, _arr)
	for (_i = 1; _i <= _len; ++_i) {
		_tmp = _arr[_i]
		
		if (!is_non_terminal(_tmp) && !is_terminal(_tmp)) {
			error_qfpos(\
				sprintf("bad syntax: '%s' not a terminal or a non-terminal",
				_tmp))
		}
	}
	
	return str
}
# </misc>
# ./_rdpg_pft.awk
# <rdpg_pft>
function RDPG_PFT_SEP() {return "."}

function _rdpg_str_to_pft_str(str, sep,    _arr, _len) {
	_len = split(str, _arr, sep ? sep : RDPG_PFT_SEP())
	return pft_arr_to_pft_str(_arr, _len)
}

function rdpg_pft_insert(tree, rule, defn,    _path) {
	_path = _rdpg_str_to_pft_str((rule " " defn), "[[:space:]]+")
	pft_insert(tree, _path)
	pft_mark(tree, _path)
}
function rdpg_pft_is_marked(tree, ind) {
	return pft_is_marked(tree, _rdpg_str_to_pft_str(ind))
}
function rdpg_pft_split(root, out_arr) {
	return split(root, out_arr, RDPG_PFT_SEP())
}
function rdpg_pft_init(tree) {
	pft_init(tree)
}
function rdpg_pft_has(tree, ind) {
	ind = _rdpg_str_to_pft_str(ind)
	return (pft_has(tree, ind) && pft_get(tree, ind))
}
function rdpg_pft_get(tree, ind) {
	return pft_pretty(pft_get(tree, _rdpg_str_to_pft_str(ind)), RDPG_PFT_SEP())
}

function rdpg_pft_cat(a, b) {
	if (!a) return b
	if (!b) return a
	return (a RDPG_PFT_SEP() b)
}
function rdpg_pft_arr_has(arr, len, what) {
	return arr_find(arr, len, what)
}
# </rdpg_pft>
# ./_generate.awk
# <generate>
function emit_func(str) {tabs_print(sprintf("%s %s", IR_FUNC(), str))}
function emit_func_end() {tabs_print(IR_FUNC_END())}
function emit_call(str) {tabs_print(sprintf("%s %s", IR_CALL(), str))}
function emit_if(str) {
	tabs_print(sprintf("%s %s %s", IR_IF(), IR_CALL(), str))
}
function emit_else_if(str) {
	tabs_print(sprintf("%s %s %s", IR_ELSE_IF(), IR_CALL(), str))
}
function emit_else(str) {tabs_print(IR_ELSE())}
function emit_return(str) {tabs_print(sprintf("%s %s", IR_RETURN(), str))}

function expose_return(str,    _arr, _tmp, _ret) {
	# expose the return only if it has valid IR syntax, so it can be considered
	# in the optimization stage
	
	_ret = str
	
	split(str, _arr)
	_tmp = _arr[1]
	if (IR_GOAL() == _tmp || IR_FAIL() == _tmp) {
		_tmp = _arr[2]
		if (IR_RETURN() == _tmp) {
			_tmp = _arr[3]
			if (IR_TRUE() == _tmp || IR_FALSE() == _tmp || IR_CALL() == _tmp)
				_ret = remove_first_field(str)
		}
	}

	return _ret
}
function emit_goal(str) {
	tabs_print(sprintf("%s",
		expose_return(sprintf("%s %s", IR_GOAL(), str))))
}
function emit_fail(str) {
	tabs_print(sprintf("%s",
		expose_return(sprintf("%s %s", IR_FAIL(), str))))
}

function emit_comment(str) {print sprintf("%s %s", IR_COMMENT(), str)}
function emit_block_open(fname) {
	tabs_print(sprintf("%s %s_%d", IR_BLOCK_OPEN(), fname, ++_B_n))
	tabs_inc()
}
function emit_block_close(fname) {
	tabs_dec()
	tabs_print(sprintf("%s %s_%d", IR_BLOCK_CLOSE(), fname, _B_n--))
}

function get_list_of_terminals(arr, len,    _symb, _i, _count, _str) {
	_count = 0
	_str = ""
	for (_i = 1; _i <= len; ++_i) {
		_symb = arr[_i]
		if (is_terminal(_symb)) {
			++_count
			_str = sprintf("%s%s", _str, _symb)
			if (_i != len)
				_str = (_str " ")
		}
	}
	return (_count) ? sprintf("%d %s", _count, _str) : ""
}
function did_only_nullables_fail(arr, len,    _i) {
	for (_i = 1; _i <= len; ++_i) {	
		if (!is_rule_nullable(arr[_i]))
			return 0
	}
	return 1
}

function tok_match_call(val) {return sprintf("%s %s", IR_TOK_MATCH(), val)}

function generate_ir_rule(tree, rule,    _current, _path, _i, _val, _arr_val,
_len_val, _is_term, _has, _is_last, _symb) {
	
	if (!_current) # first time
		_current = rule
	
	if (!rdpg_pft_has(tree, _current))
		return
	
	_val = rdpg_pft_get(tree, _current)
	_len_val = rdpg_pft_split(_val, _arr_val)
	
	for (_i = 1; _i <= _len_val; ++_i) {
		_val = _arr_val[_i]
		_is_term = is_terminal(_val)
		
		# if the current symbol is a terminal, make a tok_match call
		# else make an ordinary function call
		_symb = (_is_term) ? tok_match_call(_val) : _val
		
		if (_i == 1)
			emit_if(_symb)        # if
		else 
			emit_else_if(_symb)   # else if
			
		emit_block_open(rule)         # {
		
		_path = rdpg_pft_cat(_current, _val) # current path and value is 
		                                     # exactly where we are
		
		_is_last = rdpg_pft_is_marked(tree, _path) # are we at the last call of
		                                           # a definition?
		
		if (_is_last) {                # if last call of definition
			_has = goal_get(_path)     # and a goal was defined
			if (_has)
				emit_goal(_has)        # execute the definition goal
		
			if (_is_term)
				emit_call(IR_TOK_NEXT()) # consume the token after tok_match

			emit_return(IR_TRUE())       # definition match successful
		
		} else {
			if (_is_term)                # not last call of definition
				emit_call(IR_TOK_NEXT()) # consume the token after tok_match
			
			generate_ir_rule(tree, rule, _path)  # the same thing again until
			                                     # the end of the definition
			                                     # is reached
		}
		
		emit_block_close(rule)    # }
	}

	emit_else()                   # else
	emit_block_open(rule)         # {
	
	if (!is_rule_nullable(rule)) {    # if the rule has no epsilon production
	                                  # it can produces errors; otherwise not
	                                  
		_has = get_list_of_terminals(_arr_val, _len_val)
		if (_has)
			emit_call(sprintf("%s %s", IR_TOK_ERR(), _has))
	}
	
	_has = fail_get(_current)         # execute rule failure procedure
	if (_has)
		emit_fail(_has)
	                                  # if all calls up the same level of the if
	                                  # chain had epsilon productions, return
	                                  # true, since returning false could
	                                  # trigger an error further up the chain;
	                                  # epsilon productions trigger no errors on
	                                  # failure by definition
	
	emit_return(did_only_nullables_fail(_arr_val, _len_val) ? \
		IR_TRUE() : IR_FALSE())
	emit_block_close(rule)        # }
}

function definition_comment(rule, _str) {

	_str = get_raw_definition(rule)
	sub("\n$", "", _str)
	gsub("\n", "\ncomment ", _str)
	return _str
}
function generate_ir(tree,    _rule, _i, _end) {

	emit_comment(sprintf("generated by %s %s",
		SCRIPT_NAME(), SCRIPT_VERSION()))

	_end = rule_get_count()
	for (_i = 1; _i <= _end; ++_i) {
		_rule = rule_get(_i)
			
		emit_func(_rule)                         # function _rule()
		emit_block_open(_rule)                   # {
		emit_comment(definition_comment(_rule))  # rule definition comment
		
		if (1 == _i)                             # start the tokenizer if first
			emit_call(IR_TOK_NEXT())             # call in the parsing process
		
		generate_ir_rule(tree, _rule)            # generate the function content
		
		emit_block_close(_rule)                  # }
		emit_func_end() # mark end of func, so it becomes a paragraph
	}
}
# </generate>
# ./_doc.awk
# <user_messages>
function use_str() {
	return sprintf("Use: awk -f %s <input-file>", SCRIPT_NAME())
}

function print_use_try() {
	pstderr(use_str())
	pstderr(sprintf("Try '%s -vHelp=1' for more info", SCRIPT_NAME()))
	exit_failure()
}

function print_version() {
	print sprintf("%s %s", SCRIPT_NAME(), SCRIPT_VERSION())
	exit_success()
}

function STRICT() {return "-vStrict=1"}
function EXAMPLE() {return "-vExample=1"}
function print_help() {
print sprintf("--- %s %s ---", SCRIPT_NAME(), SCRIPT_VERSION())
print "LL(1) recursive descent parser generator"
print ""
print use_str()
print ""
print "Options:"
print sprintf("%s  - any reference to a non-defined CFG rule is an error", STRICT())
print sprintf("%s - print infix calculator example", EXAMPLE())
print "-vHelp=1    - print this screen"
print "-vVersion=1 - print version"
print ""
print sprintf("%s itself is a line oriented state machine parser which parses",
	SCRIPT_NAME())
print "by the rules described below. Note: these rules are different in meaning"
print "than the rules in the context of context free grammars. Unlike CFG rules,"
print "these only describe the sequence in which they must themselves appear in"
print "the input file."
print ""
print "Rules:"
print "'->' means 'must be followed by'"
print "'|'  means 'or'"
print "Each line of the input file must begin with a rule."
print "The rules must appear in the below order of definition."
print "Empty lines and lines which start with '#' are ignored."
print ""
print "rule -> defn"
print "defn -> defn | goal | fail | end"
print "goal -> defn | fail | end"
print "fail -> end"
print "end -> rule"
print ""
print "Here's how the above is used to describe a context free grammar:"
print "Note: the below is only a demonstration. The grammar doesn't really make sense."
print sprintf("For a grammar which does, please run with the %s flag.", EXAMPLE())
print ""
print "expression := term expr_rest"
print "term := NUMBER"
print "expr_rest := plus_minus_term expr_rest"
print "plus_minus_term := PLUS term | MINUS term | eps"
print ""
print sprintf("in %s syntax becomes:", SCRIPT_NAME())
print ""
print "rule expression"
print "defn term expr_rest"
print "end"
print "rule term"
print "defn NUMBER"
print "end"
print "rule expr_rest"
print "defn plus_minus_term expr_rest"
print "end"
print "rule plus_minus_term?"
print "defn PLUS term"
print "defn MINUS term"
print "end"
print ""
print "Note that an epsilon transition is marked by a '?' after the rule name."
print "This makes it easier for the line parser to parse. A goal can be"
print "associated with each definition. A goal is an action, usually a function"
print "call, which is executed after a successful match of the definition:"
print ""
print "rule plus_minus_term?"
print "defn PLUS term"
print "goal add()"
print "defn MINUS term"
print "goal sub()"
print "end"
print ""
print "Similarly, a single fail action can be associated with a rule:"
print ""
print "rule plus_minus_term?"
print "defn PLUS term"
print "goal add()"
print "defn MINUS term"
print "goal sub()"
print "fail exit(EXIT_FAILURE)"
print "end"
print ""
print "This fail action gets executed if none of the defn were matched."
print sprintf("%s detects left recursion and is language agnostic. It compiles", 
	SCRIPT_NAME())
print "it's input to an intermediate representation, which can then be piped"
print "into the optimizer - rdpg-opt.awk, which, depending on the optimization"
print "level, can replace naive code like 'if (foo()) {return true} else "
print "{return false}' with something more succinct like 'return foo()'. It can"
print "also get rid of redundant elses, unreachable code (defined as any code"
print "between the first return statement in the current block and the end of the"
print "same block), optimize tail recursion, and inline functions. If optimization"
print "is used, the output of the optimizer is again ir code. Ultimately, the ir"
print "is fed into some back end, like rdpg-to-c.awk, which translates it to the"
print "target language. This translation is more or less trivial, as is writing"
print "a custom back end for a desired target language. Note that in order to have"
print "a language agnostic grammar, the goal and fail actions should be written in"
print "ir as well. E.g."
print ""
print "rule plus_minus_term?"
print "defn PLUS term"
print "goal call add"
print "defn MINUS term"
print "goal call sub"
print "fail call exit EXIT_FAILURE"
print "end"
print ""
print "Similarly:"
print ""
print "rule statement"
print "defn expression SEMI"
print "fail return sync_on(SEMI)"
print "end"
print ""
print "Becomes:"
print ""
print "rule statement"
print "defn expression SEMI"
print "fail return call sync_on SEMI"
print "end"
print ""
print "Note that in the rdpg language, any lower case symbol is a non-terminal,"
print "which gets translated to a function call. Any upper case symbol is a token,"
print "which gets translated to a token matching functions. " SCRIPT_NAME() " assumes the"
print "existence of three token related functions - one for consuming a token, one for"
print "matching the current token to an expected token, and one for reporting mismatch"
print "errors. A mismatch error is generally supposed to have the form of 'expected X,"
print "got Y instead'. The assumed names of the three functions can be found in the"
print "IR_TOK_* constants."
print ""
print "It's worth mentioning that if a rule is nullable, i.e. if it ends with a"
print "'?', this in practice means that:"
print "a) token mismatches do not generate errors inside that rule"
print "b) the caller rule always returns true whether or not the nullable rule failed,"
print "given that the nullable rule is the only call, i.e. it's not a part of an if"
print "chain of calls. This is because making a rule nullable makes it optional, i.e."
print "it's ok not to match."
exit_success()
}

function print_example() {
print "# start symbol"
print "rule parse"
print "defn statements"
print "end"
print ""
print "rule statements"
print "defn statement eoi"
print "defn statement statements"
print "end"
print ""
print "rule eoi?"
print "defn EOI"
print "end"
print ""
print "# if parsing an expression failed, eat tokens until you see ';'"
print "rule statement"
print "defn expression_sync"
print "fail return call sync SEMI"
print "end"
print ""
print "# intermediate rule, so expression can fail at a single point"
print "rule expression_sync"
print "defn expression SEMI"
print "end"
print ""
print "rule expression"
print "defn term expr_rest"
print "end"
print ""
print "rule expr_rest"
print "defn plus_minus_term expr_rest"
print "end"
print ""
print "# it's ok to not have addition or subtraction in an expression"
print "rule plus_minus_term?"
print "defn PLUS term"
print "goal call add"
print "defn MINUS term"
print "goal call subt"
print "end"
print ""
print "rule term"
print "defn factor term_tail"
print "end"
print ""
print "rule term_tail"
print "defn div_mul_factor term_tail"
print "end"
print ""
print "# it's ok to not have multiplication or division in an expression"
print "rule div_mul_factor?"
print "defn MUL factor"
print "goal call mult"
print "defn DIV factor"
print "goal call divd"
print "end"
print ""
print "rule factor"
print "defn base expon"
print "end"
print ""
print "# right associative"
print "rule expon?"
print "defn EXP factor"
print "goal call power"
print "end"
print ""
print "rule base"
print "defn single NUMBER"
print "goal call push_val"
print "defn NUMBER"
print "goal call push_val"
print "defn LPAR expression RPAR"
print "end"
print ""
print "# optional negation"
print "rule single?"
print "defn MINUS"
print "goal call neg"
print "defn PLUS"
print "end"
	exit_success()
}
# </user_messages>
# ../common/_rdpg_ir.awk
# <rdpg_ir>
# Author: Vladimir Dinev
# vld.dinev@gmail.com
# 2021-03-20

# version 1.0
# A generic intermediate representation. If optimization is performed, it's
# performed on this. Then it's fed into a back-end for translation to the target
# language.
function IR_FUNC() {return "func"}
function IR_FUNC_END() {return "func_end"}
function IR_CALL() {return "call"}
function IR_IF() {return "if"}
function IR_ELSE_IF() {return "else_if"}
function IR_ELSE() {return "else"}
function IR_LOOP_START() {return "loop_start"}
function IR_LOOP_END() {return "loop_end"}
function IR_CONTINUE() {return "continue"}
function IR_RETURN() {return "return"}
function IR_GOAL() {return "goal"}
function IR_FAIL() {return "fail"}
function IR_COMMENT() {return "comment"}
function IR_BLOCK_OPEN() {return "block_open"}
function IR_BLOCK_CLOSE() {return "block_close"}
function IR_PASS_THROUGH() {return "@"} # for debugging
function IR_TOK_MATCH() {return "tok_match"}
function IR_TOK_NEXT() {return "tok_next"}
function IR_TOK_ERR() {return "tok_err_exp"}
function IR_TRUE() {return "true"}
function IR_FALSE() {return "false"}
# </rdpg_ir>
# ../../../awklib/src/awklib_prog.awk
#@ <awklib_prog>
#@ Library: prog
#@ Description: Provides program name, error, and exit handling. Unlike
#@ other libraries, the function names for this library are not
#@ prepended.
#@ Version 1.0
##
## Vladimir Dinev
## vld.dinev@gmail.com
## 2021-08-15
#@

#
#@ Description: Sets the program name to 'str'. This name can later be
#@ retrieved by get_program_name().
#@ Returns: Nothing.
#
function set_program_name(str) {

	__LB_prog_program_name__ = str
}

#
#@ Description: Provides the program name.
#@ Returns: The name as set by set_program_name().
#
function get_program_name() {

	return __LB_prog_program_name__
}

#
#@ Description: Prints 'msg' to stderr.
#@ Returns: Nothing.
#
function pstderr(msg) {

	print msg > "/dev/stderr"
}

#
#@ Description: Sets a static flag which can later be checked by
#@ should_skip_end().
#@ Returns: Nothing.
#
function skip_end_set() {

	__LB_prog_skip_end_flag__ = 1
}

#
#@ Description: Clears the flag set by skip_end_set().
#@ Returns: Nothing.
#
function skip_end_clear() {

	__LB_prog_skip_end_flag__ = 0
}

#
#@ Description: Checks the static flag set by skip_end_set().
#@ Returns: 1 if the flag is set, 0 otherwise.
#
function should_skip_end() {

	return (__LB_prog_skip_end_flag__+0)
}

#
#@ Description: Sets a static flag which can later be checked by
#@ did_error_happen().
#@ Returns: Nothing
#
function error_flag_set() {

	__LB_prog_error_flag__ = 1
}

#
#@ Description: Clears the flag set by error_flag_set().
#@ Returns: Nothing
#
function error_flag_clear() {

	__LB_prog_error_flag__ = 0
}

#
#@ Description: Checks the static flag set by error_flag_set().
#@ Returns: 1 if the flag is set, 0 otherwise.
#
function did_error_happen() {

	return (__LB_prog_error_flag__+0)
}

#
#@ Description: Sets the skip end flag, exits with error code 0.
#@ Returns: Nothing.
#
function exit_success() {
	
	skip_end_set()
	exit(0)
}

#
#@ Description: Sets the skip end flag, exits with 'code', or 1 if 'code' is 0
#@ or not given.
#@ Returns: Nothing.
#
function exit_failure(code) {

	skip_end_set()
	exit((code+0) ? code : 1)
}

#
#@ Description: Prints '<program-name>: error: msg' to stderr. Sets the
#@ error and skip end flags.
#@ Returns: Nothing.
#
function error_print(msg) {

	pstderr(sprintf("%s: error: %s", get_program_name(), msg))
	error_flag_set()
	skip_end_set()
}

#
#@ Description: Calls error_print() and quits with failure.
#@ Returns: Nothing.
#
function error_quit(msg, code) {

	error_print(msg)
	exit_failure(code)
}
#@ </awklib_prog>
# ../../../awklib/src/awklib_array.awk
#@ <awklib_array>
#@ Library: arr
#@ Description: Array functionality.
#@ Version: 1.0
##
## Vladimir Dinev
## vld.dinev@gmail.com
## 2021-08-20
#@

#
#@ Description: Clears 'arr'.
#@ Returns: Nothing.
#@ Complexity: O(1)
#
function arr_init(arr) {

	arr[""]
	delete arr
}

#
#@ Description: Clears 'arr_dest', puts all keys of 'map' in 'arr_dest'.
#@ Returns: Nothing.
#@ Complexity: O(n)
#
function arr_from_map_keys(arr_dest, map,    _i, _n) {
	
	delete arr_dest
	_i = 0
	for (_n in map)
		arr_dest[++_i] = _n
	return _i
}

#
#@ Description: Clears 'arr_dest', puts all values of 'map' in
#@ 'arr_dest'.
#@ Returns: Nothing.
#@ Complexity: O(n)
#
function arr_from_map_vals(arr_dest, map,    _i, _n) {
	
	delete arr_dest
	_i = 0
	for (_n in map)
		arr_dest[++_i] = map[_n]
	return _i
}

#
#@ Description: Clears 'arr_dest' and copies the range defined by
#@ 'src_begin' and 'src_end' from 'arr_src' to 'arr_dest'. The range is
#@ inclusive. If 'src_begin' is larger than 'src_end', nothing is
#@ copied.
#@ Returns: The length of 'arr_dest'.
#@ Complexity: O(n)
#
function arr_range(arr_dest, arr_src, src_begin, src_end,    _i, _n) {
	
	delete arr_dest
	_n = 0
	for (_i = src_begin; _i <= src_end; ++_i)
		arr_dest[++_n] = arr_src[_i]
	return _n
}

#
#@ Description: Clears 'arr_dest' and copies 'arr_src' into 'arr_dest'.
#@ Returns: The length of 'arr_dest'.
#@ Complexity: O(n)
#
function arr_copy(arr_dest, arr_src, src_len) {

	return arr_range(arr_dest, arr_src, 1, src_len)
}

#
#@ Description: Appends 'arr_src' to the end of 'arr_dest'.
#@ Returns: The length of 'arr_dest' after appending.
#@ Complexity: O(n)
#
function arr_append(arr_dest, dest_len, arr_src, src_len,    _i) {

	for (_i = 1; _i <= src_len; ++_i)
		arr_dest[++dest_len] = arr_src[_i]
	return dest_len
}

#
#@ Description: Clears 'arr_dest', places all elements from 'arr_src'
#@ which are at indexes contained in 'arr_ind' in 'arr_dest'. E.g. given
#@ 'arr_ind[1] = 5; arr_ind[2] = 6', 'arr_dest' will get
#@ 'arr_dest[1] = arr_src[5]; arr_dest[2] = arr_src[6]'
#@ Returns: The length of 'arr_dest'.
#@ Complexity: O(n)
#
function arr_gather(arr_dest, arr_src, arr_ind, ind_len,    _i, _n) {
	
	delete arr_dest
	_n = 0
	for (_i = 1; _i <= ind_len; ++_i)
		arr_dest[++_n] = arr_src[arr_ind[_i]]
	return _n
}

#
#@ Description: Finds the index of the first match for 'regex' in 'arr'.
#@ Returns: The index of the first match, 0 if not match is found.
#@ Complexity: O(n)
#
function arr_match_ind_first(arr, len, regex,    _i) {
	
	for (_i = 1; _i <= len; ++_i) {
		if (match(arr[_i], regex))
			return _i
	}
	return 0
}

#
#@ Description: Clears 'arr_dest', places the indexes for all matches
#@ for 'regex' in 'arr_src' in 'arr_dest'.
#@ Returns: The length of 'arr_dest'.
#@ Complexity: O(n)
#
function arr_match_ind_all(arr_dest, arr_src, src_len, regex,    _i,
_n) {
	
	delete arr_dest
	_n = 0
	for (_i = 1; _i <= src_len; ++_i) {
		if (match(arr_src[_i], regex))
			arr_dest[++_n] = _i
	}
	return _n
}

#
#@ Description: Clears 'arr_dest' and copies all elements which match
#@ 'regex' from 'arr_src' to 'arr_dest'.
#@ Returns: The length of 'arr_dest'.
#@ Complexity: O(n)
#
function arr_match(arr_dest, arr_src, src_len, regex,    _i, _n) {

	delete arr_dest
	_n = 0
	for (_i = 1; _i <= src_len; ++_i) {
		if (match(arr_src[_i], regex))
			arr_dest[++_n] = arr_src[_i]
	}
	return _n
}

#
#@ Description: Finds the index of the first non-match for 'regex' in
#@ 'arr'.
#@ Returns: The index of the first non-match, 0 if all match.
#@ Complexity: O(n)
#
function arr_dont_match_ind_first(arr, len, regex,    _i) {
	
	for (_i = 1; _i <= len; ++_i) {
		if (!match(arr[_i], regex))
			return _i
	}
	return 0
}

#
#@ Description: Clears 'arr_dest', places the indexes for all
#@ non-matches for 'regex' in 'arr_src' in 'arr_dest'.
#@ Returns: The length of 'arr_dest'.
#@ Complexity: O(n)
#
function arr_dont_match_ind_all(arr_dest, arr_src, src_len, regex,
    _i, _n) {
	
	delete arr_dest
	_n = 0
	for (_i = 1; _i <= src_len; ++_i) {
		if (!match(arr_src[_i], regex))
			arr_dest[++_n] = _i
	}
	return _n
}

#
#@ Description: Clears 'arr_dest' and copies all elements which do not
#@ match 'regex' from 'arr_src' to 'arr_dest'.
#@ Returns: The length of 'arr_dest'.
#@ Complexity: O(n)
#
function arr_dont_match(arr_dest, arr_src, src_len, regex,    _i, _n) {

	delete arr_dest
	_n = 0
	for (_i = 1; _i <= src_len; ++_i) {
		if (!match(arr_src[_i], regex))
			arr_dest[++_n] = arr_src[_i]
	}
	return _n
}

#
#@ Description: Calls 'sub()' for every element of 'arr' like
#@ 'sub(regex, subst, arr[i])'
#@ Returns: The number of substitutions made.
#@ Complexity: O(n)
#
function arr_sub(arr, len, regex, subst,    _i, _n) {

	_n = 0
	for (_i = 1; _i <= len; ++_i)
		_n += sub(regex, subst, arr[_i])
	return _n
}

#
#@ Description: Calls gsub() for every element of 'arr' like
#@ 'gsub(regex, subst, arr[i])'
#@ Returns: The number of substitutions made.
#@ Complexity: O(n)
#
function arr_gsub(arr, len, regex, subst,    _i, _n) {

	_n = 0
	for (_i = 1; _i <= len; ++_i)
		_n += gsub(regex, subst, arr[_i])
	return _n
}

#
#@ Description: Checks if 'arr_a' and 'arr_b' have the same elements.
#@ Returns: 1 if the arrays are equal, 0 otherwise.
#@ Complexity: O(n)
#
function arr_is_eq(arr_a, len_a, arr_b, len_b,    _i) {

	if (len_a != len_b)
		return 0
	for (_i = 1; _i <= len_a; ++_i) {
		if (arr_a[_i] != arr_b[_i])
			return 0
	}
	return 1
}

#
#@ Description: Finds 'val' in 'arr'.
#@ Returns: The index of 'val' if it's found, 0 otherwise.
#@ Complexity: O(n)
#
function arr_find(arr, len, val,    _i) {
	
	for (_i = 1; _i <= len; ++_i) {
		if (arr[_i] == val)
			return _i
	}
	return 0
}

#
#@ Description: Concatenates all elements of 'arr' into a single string.
#@ The elements are separated by 'sep'. It 'sep' is not given, " " is
#@ used. 'sep' does not appear after the last element.
#@ Returns: The string representation of 'arr'.
#@ Complexity: O(n)
#
function arr_to_str(arr, len, sep,    _i, _str) {
	
	if (len < 1)
		return ""
	
	if (!sep)
		sep = " "
		
	_str = arr[1]
	for (_i = 2; _i <= len; ++_i)
		_str = (_str sep arr[_i])
	
	return _str
}

#
#@ Description: Prints 'arr' to stdout.
#@ Returns: Nothing.
#@ Complexity: O(n)
#
function arr_print(arr, len, sep) {

	print arr_to_str(arr, len, sep)
}
#@ </awklib_array>
# ../../../awklib/src/awklib_vect.awk
#@ <awklib_vect>
#@ Library: vect
#@ Description: Vector functionality. A vector is as array which is
#@ aware of its own size.
#@ Dependencies: awklib_array.awk
#@ Version: 1.0
##
## Vladimir Dinev
## vld.dinev@gmail.com
## 2021-08-20
#@

#
#@ Description: Clears 'vect', initializes it with length 0.
#@ Returns: Nothing.
#@ Complexity: O(1)
#
function vect_init(vect) {

	vect[""]
	delete vect
	vect[_VECT_LEN()] = 0
}

#
#@ Description: Initializes 'vect' to a copy of 'arr'.
#@ Returns: Nothing.
#@ Complexity: O(n)
#
function vect_init_arr(vect, arr, len,    _i) {
	
	vect_init(vect)
	for (_i = 1; _i <= len; ++_i)
		vect[++vect[_VECT_LEN()]] = arr[_i]
}

#
#@ Description: Appends 'val' to 'vect'.
#@ Returns: Nothing.
#@ Complexity: O(1)
#
function vect_push(vect, val) {

	vect[++vect[_VECT_LEN()]] = val
}

#
#@ Description: Appends 'arr' to 'vect'.
#@ Returns: Nothing.
#@ Complexity: O(n)
#
function vect_push_arr(vect, arr, len,    _i) {

	for (_i = 1; _i <= len; ++_i)
		vect[++vect[_VECT_LEN()]] = arr[_i]
}

#
#@ Description: Retrieves the last value from 'vect'.
#@ Returns: The last element.
#@ Complexity: O(1)
#
function vect_peek(vect) {

	return vect[vect[_VECT_LEN()]]
}

#
#@ Description: Removes the last element of 'vect'.
#@ Returns: Nothing.
#@ Complexity: O(1)
#
function vect_pop(vect) {

	vect[--vect[_VECT_LEN()]]
}

#
#@ Description: Provides the length.
#@ Returns: The length of 'vect'.
#@ Complexity: O(1)
#
function vect_len(vect) {
	
	return vect[_VECT_LEN()]
}

#
#@ Description: Indicates if 'vect' is empty or not.
#@ Returns: 1 if 'vect' is empty, 0 otherwise.
#@ Complexity: O(1)
#
function vect_is_empty(vect) {

	return (!vect[_VECT_LEN()])
}

#
#@ Description: Removes the element in 'vect' at index 'ind' by moving
#@ all further elements one to the left.
#@ Returns: Nothing.
#@ Complexity: O(n)
#
function vect_del_ind(vect, ind,    _i, _len) {
	
	_len = vect[_VECT_LEN()]
	for (_i = ind; _i < _len; ++_i)
		vect[_i] = vect[_i+1]
	--vect[_VECT_LEN()]
}

#
#@ Description: Removes 'val' from 'vect' by  if (arr_find())
#@ vect_del_ind().
#@ Returns: Nothing.
#@ Complexity: O(n)
#
function vect_del_val(vect, val,    _ind) {
	
	if (_ind = arr_find(vect, vect[_VECT_LEN()], val))
		vect_del_ind(vect, _ind)
}

#
#@ Description: Removes the element at 'ind' from 'vect' by replacing it
#@ with the last element.
#@ Returns: Nothing
#@ Complexity: O(1)
#
function vect_swap_pop_ind(vect, ind) {
	
	vect[ind] = vect[vect[_VECT_LEN()]]
	--vect[_VECT_LEN()]
}

#
#@ Description: Removes the first instance of 'val' from 'vect' by
#@ if (arr_find()) vect_swap_pop_ind().
#@ Returns: Nothing.
#@ Complexity: O(1)
#
function vect_swap_pop_val(vect, val, _ind) {

	if (_ind = arr_find(vect, vect[_VECT_LEN()], val))
		vect_swap_pop_ind(vect, _ind)
}

function _VECT_LEN() {return "len"}
#@ </awklib_vect>
# ../../../awklib/src/awklib_tabs.awk
#@ <awklib_tabs>
#@ Library: tabs
#@ Description: String indentation.
#@ Version: 1.0
##
## Vladimir Dinev
## vld.dinev@gmail.com
## 2021-08-16
#@

#
#@ Description: Adds a tab to the indentation string.
#@ Returns: Nothing.
#
function tabs_inc() {

	++__LB_tabs_tabs_num__
	__LB_tabs_tabs_str__ = (__LB_tabs_tabs_str__ "\t")
}

#
#@ Description: Removes a tab from the indentation string.
#@ Returns: Nothing.
#
function tabs_dec() {

	if (__LB_tabs_tabs_num__) {
		--__LB_tabs_tabs_num__
		__LB_tabs_tabs_str__ = substr(__LB_tabs_tabs_str__, 1,
			__LB_tabs_tabs_num__)
	}
}

#
#@ Description: Indicates the tab level.
#@ Returns: The number of tabs used for indentation.
#
function tabs_num() {

	return __LB_tabs_tabs_num__
}

#
#@ Description: Provides all indentation tabs as a string.
#@ Returns: The indentation string.
#
function tabs_get() {

	return (__LB_tabs_tabs_str__ "")
}

#
#@ Description: Adds indentation to 'str'.
#@ Returns: 'str' prepended with the current number of tabs.
#
function tabs_indent(str) {

	return (__LB_tabs_tabs_str__ str)
}

#
#@ Description: Prints the indented 'str' to stdout without a new line
#@ at the end.
#@ Returns: Nothing.
#
function tabs_print_str(str) {

	printf("%s", tabs_indent(str))
}

#
#@ Description: Prints the indented 'str' to stdout with a new line at
#@ the end.
#@ Returns: Nothing.
#
function tabs_print(str) {

	print tabs_indent(str)
}
#@ </awklib_tabs>
# ../../../awklib/src/awklib_prefix_tree.awk
#@ <awklib_prefix_tree>
#@ Library: pft
#@ Description: A prefix tree implementation. E.g. conceptually, if you
#@ insert "this" and "that", you'd get:
#@ pft["t"] = "h"
#@ pft["th"] = "ia"
#@ pft["thi"] = "s"
#@ pft["this"] = ""
#@ pft["tha"] = "t"
#@ pft["that"] = ""
#@ However, all units must be separated by PFT_SEP(), so in this case
#@ "this" should be ("t" PFT_SEP() "h" PFT_SEP() "i" PFT_SEP() "s").
#@ Similar for "that". PFT_SEP() is a non-printable character. To make
#@ any key or value from a pft printable, use pft_pretty().
#@ Version: 1.2
##
## Vladimir Dinev
## vld.dinev@gmail.com
## 2022-01-14
#@

# <public>
#@ Description: The prefix tree path delimiter.
#@ Returns: Some non-printable character.
#
function PFT_SEP() {

	return "\034"
}

# "\034" is inlined as a constant; make sure it's in sync with PFT_SEP()
function _PFT_LAST_NODE() {

	return "\034[^\034]+$"
}

#
#@ Description: Clears 'pft'.
#@ Returns: Nothing.
#@ Complexity: O(1)
#
function pft_init(pft) {

	pft[""]
	delete pft
}

#
#@ Description: Inserts 'path' in 'pft'. 'path' has to be a PFT_SEP() delimited
#@ string.
#@ Returns: Nothing.
#@ Complexity: O(n)
#
function pft_insert(pft, path,    _val) {
# inserts "a.b.c", "a.x.y" backwards, so you get
# pft["a.b.c"] = ""
# pft["a.b"] = "c"
# pft["a"] = "b"
# pft["a.x.y"] = ""
# pft["a.x"] = "y"
# pft["a"] = "b.x"

	if (!path)
		return

	_pft_add(pft, path, _val)

	if (match(path, _PFT_LAST_NODE())) {
		_val = substr(path, RSTART+1, RLENGTH)
		path = substr(path, 1, RSTART-1)
	} else {
		return
	}

	pft_insert(pft, path, _val)
}

#
#@ Description: If 'path' exists in 'pft', makes 'path' and all paths stemming
#@ from 'path' unreachable. 'path' has to be a PFT_SEP() delimited string.
#@ Returns: Nothing.
#@ Complexity: O(n)
#
function pft_rm(pft, path,    _arr, _arr2, _i, _len, _last, _no_tail, _tmp) {

	if (pft_has(pft, path)) {

		delete pft[path]

		if ((_len = pft_split(_arr, path)) > 1) {

			_last = _arr[_len]
			_no_tail = pft_arr_to_pft_str(_arr, _len-1)

			_len = pft_split(_arr, pft[_no_tail])

			_tmp = 0
			for (_i = 1; _i <= _len; ++_i) {

				if (_arr[_i] != _last)
					_arr2[++_tmp] = _arr[_i]
			}

			pft[_no_tail] = pft_arr_to_pft_str(_arr2, _tmp)
		}
	}
}

#
#@ Description: Marks 'path' in 'pft', so pft_is_marked() will return
#@ 1 when asked about 'path'. The purpose of this is so also
#@ intermediate paths, and not only leaf nodes, can be considered during
#@ traversal. E.g. if you insert "this", "than", and "thank" in 'pft'
#@ and want to get these words out again, when you traverse only "this"
#@ and "thank" will be leaf nodes in the pft. Unless "than" is somehow
#@ marked, you will have no way to know "than" is actually a word, and
#@ not only an intermediate path to "thank", like "tha" would be.
#@ Returns: Nothing.
#@ Complexity: O(1)
#
function pft_mark(pft, path) {

	pft[(_PFT_MARK_SEP() path)]
}

#
#@ Description: Indicates if 'path' is marked in 'pft'.
#@ Returns: 1 if it is, 0 otherwise.
#@ Complexity: O(1)
#
function pft_is_marked(pft, path) {

	return ((_PFT_MARK_SEP() path) in pft)
}

#
#@ Description: Unmarks 'path' from 'pft' if it was previously marked.
#@ Returns: Nothing.
#@ Complexity: O(1)
#
function pft_unmark(pft, path) {

	if (pft_is_marked(pft, path))
		delete pft[(_PFT_MARK_SEP() path)]
}

#
#@ Description: Retrieves 'key' from 'pft'.
#@ Returns: pft[key] if 'key' exists in 'pft', the empty string
#@ otherwise. Use only if pft_has() has returned 1.
#@ Complexity: O(1)
#
function pft_get(pft, key) {

	return pft_has(pft, key) ? pft[key] : ""
}

#
#@ Description: Indicates whether 'key' exists in 'pft'.
#@ Returns: 1 if 'key' is found in 'pft', 0 otherwise.
#@ Complexity: O(1)
#
function pft_has(pft, key) {

	return (key in pft)
}

#
#@ Description: Splits 'pft_str' in 'arr' using PFT_SEP() as a
#@ separator. I.e. Splits what pft_get() returns.
#@ Returns: The length of 'arr'.
#@ Complexity: O(n)
#
function pft_split(arr, pft_str) {

	return split(pft_str, arr, PFT_SEP())
}


#
#@ Description: Splits 'pft_str', finds out if 'node' exists in
#@ the array created by the split.
#@ Returns: 1 if 'node' is a path in 'pft_str', 0 otherwise.
#@ Complexity: O(n)
#
function pft_path_has(pft_str, node,    _i, _len, _arr) {

	_len = pft_split(_arr, pft_str)
	for (_i = 1; _i <= _len; ++_i) {
		if (_arr[_i] == node)
			return 1
	}
	return 0
}

#
#@ Description: Turns 'arr' into a PFT_SEP() delimited string.
#@ Returns: The pft string representation of 'arr'.
#@ Complexity: O(n)
#
function pft_arr_to_pft_str(arr, len,    _i, _str) {

	_str = ""
	for (_i = 1; _i < len; ++_i)
		_str = (_str arr[_i] PFT_SEP())
	if (_i == len)
		_str = (_str arr[_i])
	return _str
}

#
#@ Description: Delimits the strings 'a' and 'b' with PFT_SEP().
#@ Returns: If only b is empty, returns a. If only a is empty, returns
#@ b. If both are empty, returns the empty string. Returns
#@ (a PFT_SEP() b) otherwise.
#@ Complexity: O(awk-concatenation)
#
function pft_cat(a, b) {

	if (("" != a) && ("" != b)) return (a PFT_SEP() b)
	if ("" == b) return a
	if ("" == a) return b
	return ""
}

#
#@ Description: Replaces all internal separators in 'pft_str' with
#@ 'sep'. If 'sep' is not given, "." is used.
#@ Returns: A printable representation of 'pft_str'.
#@ Complexity: O(n)
#
function pft_pretty(pft_str, sep) {

	gsub((PFT_SEP() "|" _PFT_MARK_SEP()), ((!sep) ? "." : sep), pft_str)
	return pft_str
}

#
#@ Description: Builds a string by performing a depth first search
#@ traversal of 'pft' starting from 'root'. The end result is all marked
#@ and leaf nodes subseparated by 'subsep' in their order of insertion
#@ separated by 'sep'. If 'sep' is not given, " " is used. If 'subsep'
#@ is not given, PFT_SEP() is removed from the node strings. E.g. for
#@ the words "this" and "that", if 'sep' is " -> "
#@ If 'subsep' is blank, the result shall be
#@ "this -> that"
#@ If 'subsep' is '-', the result shall be
#@ "t-h-i-s -> t-h-a-t"
#@ 'sep' does not appear after the last element.
#@ Returns: A string representation 'pft'.
#@ Complexity: O(n)
#
function pft_to_str_dfs(pft, root, sep, subsep,    _arr, _i, _len, _str,
_tmp) {

	if (!pft_has(pft, root))
		return ""

	if (!(_get = pft_get(pft, root)))
		return root

	if (pft_is_marked(pft, root))
		_str = root

	if (!sep)
		sep = " "

	_tmp = ""
	_len = pft_split(_arr, _get)
	for (_i = 1; _i <= _len; ++_i) {

		if (_tmp = pft_to_str_dfs(pft, pft_cat(root, _arr[_i]),
			sep, subsep)) {
			_str = (_str) ? (_str sep _tmp) : _tmp
		}
	}

	gsub(PFT_SEP(), subsep, _str)
	return _str
}

#
#@ Description: Prints the string representation of 'pft' to stdout as
#@ returned by pft_to_str_dfs().
#@ Returns: Nothing.
#@ Complexity: O(n)
#
function pft_print_dfs(pft, root, sep, subsep) {

	print pft_to_str_dfs(pft, root, sep, subsep)
}

#
#@ Description: Returns the dump of 'pft' as a single multi line string
#@ in the format "pft[<key>] = <val>" in no particular order. Marked
#@ nodes always begin with 'sep'.
#@ Returns: Nothing.
#@ Complexity: O(n)
#
function pft_str_dump(pft, sep,    _n, _str, _ret) {

	for (_n in pft) {
		_str = sprintf("pft[\"%s\"] = \"%s\"",
				pft_pretty(_n, sep), pft_pretty(pft[_n], sep))
		_ret = (_ret) ? (_ret "\n" _str) : _str
	}
	return _ret
}

#
#@ Description: Prints the dump of 'pft to stdout as returned by
#@ pft_str_dump().
#@ Returns: Nothing.
#@ Complexity: O(n)
#
function pft_print_dump(pft, sep) {

	print pft_str_dump(pft, sep)
}
# </public>

function _pft_add(pft, key, val,    _get) {

	if ((_get = pft_get(pft, key))) {
		if (val && !pft_path_has(_get, val)) {
			pft[key] = pft_cat(_get, val)
		}
	} else {
		pft[key] = val
	}
}

function _PFT_MARK_SEP() {return "mark\006"}
#@ </awklib_prefix_tree>
# </includes>
