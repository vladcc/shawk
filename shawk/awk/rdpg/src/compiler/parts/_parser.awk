# <parser>
# <lexer>
# <lex_awk>
# generated by lex-awk.awk 1.7.3

# <lex_usr_defined>
# The user implements the following:
# lex_usr_get_line()
# lex_usr_on_unknown_ch()
# lex_usr_get_word()
# lex_usr_on_comment()
# </lex_usr_defined>

# <lex_public>
# <lex_constants>

# the only way to have immutable values; use as constants
function COLON() {return ":"}
function BAR() {return "|"}
function SEMI() {return ";"}
function QMARK() {return "?"}
function STAR() {return "*"}
function PLUS() {return "+"}
function ESC() {return "\\"}
function TOK_EOI() {return "EOI"}
function START_SYM() {return "start"}
function TERM() {return "terminal"}
function NONT() {return "non-terminal"}
function TOK_ERROR() {return "error"}

function CH_CLS_SPACE() {return 1}
function CH_CLS_WORD() {return 2}
function CH_CLS_NUMBER() {return 3}
function CH_CLS_CMNT() {return 4}
function CH_CLS_NEW_LINE() {return 5}
function CH_CLS_EOI() {return 6}
function CH_CLS_AUTO_1_() {return 7}
function CH_CLS_AUTO_2_() {return 8}
function CH_CLS_AUTO_3_() {return 9}
function CH_CLS_AUTO_4_() {return 10}
function CH_CLS_AUTO_5_() {return 11}
function CH_CLS_AUTO_6_() {return 12}
function CH_CLS_AUTO_7_() {return 13}
# </lex_constants>

# read the next character; advance the input
function lex_read_line(    _ln) {
	# Note: the user defines lex_usr_get_line()
	if (_ln = lex_usr_get_line()) {
		_B_lex_line_str = _ln
		split(_B_lex_line_str, _B_lex_input_line, "")
		++_B_lex_line_no
		_B_lex_line_pos = 1
		return 1
	}
	_B_lex_line_pos = length(_B_lex_line_str)+2
	return 0
}

# read the next character and advance the input
function lex_read_ch() {
	_B_lex_curr_ch = _B_lex_input_line[_B_lex_line_pos++]
	_B_lex_peek_ch = _B_lex_input_line[_B_lex_line_pos]
	if (_B_lex_peek_ch != "" || lex_read_line())
		return _B_lex_curr_ch
	else if ("" == _B_lex_curr_ch)
		--_B_lex_line_pos
	return _B_lex_curr_ch
}

# return the last read character
function lex_curr_ch()
{return _B_lex_curr_ch}

# return the next character, but do not advance the input
function lex_peek_ch()
{return _B_lex_peek_ch}

# return the position in the current line of input
function lex_get_pos()
{return (_B_lex_line_pos-1)}

# return the current line number
function lex_get_line_no()
{return _B_lex_line_no}

# return the last read token
function lex_curr_tok()
{return _B_lex_curr_tok}

# see if your token is the same as the one in the lexer
function lex_match_tok(str)
{return (str == _B_lex_curr_tok)}

# clear the lexer write space
function lex_save_init()
{_B_lex_saved = ""}

# save the last read character
function lex_save_curr_ch()
{_B_lex_saved = (_B_lex_saved _B_lex_curr_ch)}

# return the saved string
function lex_get_saved()
{return _B_lex_saved}

# character classes
function lex_is_ch_cls(ch, cls)
{return (cls == _B_lex_ch_tbl[ch])}

function lex_is_curr_ch_cls(cls)
{return (cls == _B_lex_ch_tbl[_B_lex_curr_ch])}

function lex_is_next_ch_cls(cls)
{return (cls == _B_lex_ch_tbl[_B_lex_peek_ch])}

function lex_get_ch_cls(ch)
{return _B_lex_ch_tbl[ch]}

# see if what's in the lexer's write space is a keyword
function lex_is_saved_a_keyword()
{return (_B_lex_saved in _B_lex_keywords_tbl)}

# generate position string
function lex_get_pos_str(last_tok_txt,    _str, _offs) {
	return lex_pos_str_build(_B_lex_line_str, lex_get_pos(), last_tok_txt)
}
function lex_pos_str_build(line_str, pos, last_tok_txt,    _str, _offs) {
	_offs = (last_tok_txt) ? length(last_tok_txt) : 1
	_str = substr(line_str, 1, pos-_offs)
	gsub("[^[:space:]]|\\n", " ", _str)
	return (line_str (_str "^"))
}

# call this first
function lex_init() {
	# '_B' variables are 'bound' to the lexer, i.e. 'private'
	if (!_B_lex_are_tables_init) {
		_lex_init_ch_tbl()
		_lex_init_keywords()
		_B_lex_are_tables_init = 1
	}
	_B_lex_curr_ch = ""
	_B_lex_curr_ch_cls_cache = ""
	_B_lex_curr_tok = "error"
	_B_lex_line_no = 0
	_B_lex_line_pos = 0
	_B_lex_peek_ch = ""
	_B_lex_peeked_ch_cache = ""
	_B_lex_saved = ""
	lex_read_line()
}

# return the next token; constants are inlined for performance
function lex_next() {
	_B_lex_curr_tok = "error"
	while (1) {
		_B_lex_curr_ch_cls_cache = _B_lex_ch_tbl[lex_read_ch()]
		if (1 == _B_lex_curr_ch_cls_cache) { # CH_CLS_SPACE()
			continue
		} else if (2 == _B_lex_curr_ch_cls_cache) { # CH_CLS_WORD()
			_B_lex_curr_tok = lex_usr_get_word()
		} else if (4 == _B_lex_curr_ch_cls_cache) { # CH_CLS_CMNT()
			_B_lex_curr_tok = lex_usr_on_comment()
		} else if (5 == _B_lex_curr_ch_cls_cache) { # CH_CLS_NEW_LINE()
			continue
		} else if (6 == _B_lex_curr_ch_cls_cache) { # CH_CLS_EOI()
			_B_lex_curr_tok = TOK_EOI()
		} else if (7 == _B_lex_curr_ch_cls_cache) { # CH_CLS_AUTO_1_()
			_B_lex_curr_tok = ":"
		} else if (8 == _B_lex_curr_ch_cls_cache) { # CH_CLS_AUTO_2_()
			_B_lex_curr_tok = "|"
		} else if (9 == _B_lex_curr_ch_cls_cache) { # CH_CLS_AUTO_3_()
			_B_lex_curr_tok = ";"
		} else if (10 == _B_lex_curr_ch_cls_cache) { # CH_CLS_AUTO_4_()
			_B_lex_curr_tok = "?"
		} else if (11 == _B_lex_curr_ch_cls_cache) { # CH_CLS_AUTO_5_()
			_B_lex_curr_tok = "*"
		} else if (12 == _B_lex_curr_ch_cls_cache) { # CH_CLS_AUTO_6_()
			_B_lex_curr_tok = "+"
		} else if (13 == _B_lex_curr_ch_cls_cache) { # CH_CLS_AUTO_7_()
			_B_lex_curr_tok = "\\"
		} else {
			_B_lex_curr_tok = lex_usr_on_unknown_ch()
		}
		break
	}
	return _B_lex_curr_tok
}
# </lex_public>

# <lex_private>
# initialize the lexer tables
function _lex_init_keywords() {
	_B_lex_keywords_tbl["start"] = 1
}
function _lex_init_ch_tbl() {
	_B_lex_ch_tbl[" "] = CH_CLS_SPACE()
	_B_lex_ch_tbl["\t"] = CH_CLS_SPACE()
	_B_lex_ch_tbl["a"] = CH_CLS_WORD()
	_B_lex_ch_tbl["b"] = CH_CLS_WORD()
	_B_lex_ch_tbl["c"] = CH_CLS_WORD()
	_B_lex_ch_tbl["d"] = CH_CLS_WORD()
	_B_lex_ch_tbl["e"] = CH_CLS_WORD()
	_B_lex_ch_tbl["f"] = CH_CLS_WORD()
	_B_lex_ch_tbl["g"] = CH_CLS_WORD()
	_B_lex_ch_tbl["h"] = CH_CLS_WORD()
	_B_lex_ch_tbl["i"] = CH_CLS_WORD()
	_B_lex_ch_tbl["j"] = CH_CLS_WORD()
	_B_lex_ch_tbl["k"] = CH_CLS_WORD()
	_B_lex_ch_tbl["l"] = CH_CLS_WORD()
	_B_lex_ch_tbl["m"] = CH_CLS_WORD()
	_B_lex_ch_tbl["n"] = CH_CLS_WORD()
	_B_lex_ch_tbl["o"] = CH_CLS_WORD()
	_B_lex_ch_tbl["p"] = CH_CLS_WORD()
	_B_lex_ch_tbl["q"] = CH_CLS_WORD()
	_B_lex_ch_tbl["r"] = CH_CLS_WORD()
	_B_lex_ch_tbl["s"] = CH_CLS_WORD()
	_B_lex_ch_tbl["t"] = CH_CLS_WORD()
	_B_lex_ch_tbl["u"] = CH_CLS_WORD()
	_B_lex_ch_tbl["v"] = CH_CLS_WORD()
	_B_lex_ch_tbl["w"] = CH_CLS_WORD()
	_B_lex_ch_tbl["x"] = CH_CLS_WORD()
	_B_lex_ch_tbl["y"] = CH_CLS_WORD()
	_B_lex_ch_tbl["z"] = CH_CLS_WORD()
	_B_lex_ch_tbl["A"] = CH_CLS_WORD()
	_B_lex_ch_tbl["B"] = CH_CLS_WORD()
	_B_lex_ch_tbl["C"] = CH_CLS_WORD()
	_B_lex_ch_tbl["D"] = CH_CLS_WORD()
	_B_lex_ch_tbl["E"] = CH_CLS_WORD()
	_B_lex_ch_tbl["F"] = CH_CLS_WORD()
	_B_lex_ch_tbl["G"] = CH_CLS_WORD()
	_B_lex_ch_tbl["H"] = CH_CLS_WORD()
	_B_lex_ch_tbl["I"] = CH_CLS_WORD()
	_B_lex_ch_tbl["J"] = CH_CLS_WORD()
	_B_lex_ch_tbl["K"] = CH_CLS_WORD()
	_B_lex_ch_tbl["L"] = CH_CLS_WORD()
	_B_lex_ch_tbl["M"] = CH_CLS_WORD()
	_B_lex_ch_tbl["N"] = CH_CLS_WORD()
	_B_lex_ch_tbl["O"] = CH_CLS_WORD()
	_B_lex_ch_tbl["P"] = CH_CLS_WORD()
	_B_lex_ch_tbl["Q"] = CH_CLS_WORD()
	_B_lex_ch_tbl["R"] = CH_CLS_WORD()
	_B_lex_ch_tbl["S"] = CH_CLS_WORD()
	_B_lex_ch_tbl["T"] = CH_CLS_WORD()
	_B_lex_ch_tbl["U"] = CH_CLS_WORD()
	_B_lex_ch_tbl["V"] = CH_CLS_WORD()
	_B_lex_ch_tbl["W"] = CH_CLS_WORD()
	_B_lex_ch_tbl["X"] = CH_CLS_WORD()
	_B_lex_ch_tbl["Y"] = CH_CLS_WORD()
	_B_lex_ch_tbl["Z"] = CH_CLS_WORD()
	_B_lex_ch_tbl["_"] = CH_CLS_WORD()
	_B_lex_ch_tbl["0"] = CH_CLS_NUMBER()
	_B_lex_ch_tbl["1"] = CH_CLS_NUMBER()
	_B_lex_ch_tbl["2"] = CH_CLS_NUMBER()
	_B_lex_ch_tbl["3"] = CH_CLS_NUMBER()
	_B_lex_ch_tbl["4"] = CH_CLS_NUMBER()
	_B_lex_ch_tbl["5"] = CH_CLS_NUMBER()
	_B_lex_ch_tbl["6"] = CH_CLS_NUMBER()
	_B_lex_ch_tbl["7"] = CH_CLS_NUMBER()
	_B_lex_ch_tbl["8"] = CH_CLS_NUMBER()
	_B_lex_ch_tbl["9"] = CH_CLS_NUMBER()
	_B_lex_ch_tbl["#"] = CH_CLS_CMNT()
	_B_lex_ch_tbl["\n"] = CH_CLS_NEW_LINE()
	_B_lex_ch_tbl[""] = CH_CLS_EOI()
	_B_lex_ch_tbl[":"] = CH_CLS_AUTO_1_()
	_B_lex_ch_tbl["|"] = CH_CLS_AUTO_2_()
	_B_lex_ch_tbl[";"] = CH_CLS_AUTO_3_()
	_B_lex_ch_tbl["?"] = CH_CLS_AUTO_4_()
	_B_lex_ch_tbl["*"] = CH_CLS_AUTO_5_()
	_B_lex_ch_tbl["+"] = CH_CLS_AUTO_6_()
	_B_lex_ch_tbl["\\"] = CH_CLS_AUTO_7_()
}
# </lex_private>
# </lex_awk>
# <lex_usr>
function parsing_error_happened() {return _B_parsing_error_flag}
function parsing_error_set() {_B_parsing_error_flag = 1}

function _tok_prev_set(tok) {_B_lex_tok_prev = tok}
function _tok_prev()        {return _B_lex_tok_prev}

function tok_next() {
	_tok_prev_set(lex_curr_tok())
	return lex_next()
}
function tok_curr() {return lex_curr_tok()}
function tok_err(    _str, _i, _end, _arr, _exp, _prev) {
	parsing_error_set()

	_str = sprintf("file %s, line %d, pos %d: unexpected '%s'", \
		fname(), lex_get_line_no(), lex_get_pos(), lex_curr_tok())

	if (_prev = _tok_prev())
		_str = (_str sprintf(" after '%s'", _prev))
	_str = (_str "\n")
	_str = (_str sprintf("%s\n", lex_get_pos_str()))

	_end = rdpg_expect(_arr)
	for (_i = 1; _i <= _end; ++_i)
		_exp = (_exp sprintf("'%s' ", _arr[_i]))

	if (1 == _end)
		_str = (_str sprintf("expected: %s", _exp))
	else if (_end > 1)
		_str = (_str sprintf("expected one of: %s", _exp))

	error_print((_str "\n"))

	if_fatal_exit()
}

function lex_usr_get_line(    _res) {
	if ((_res = getline) > 0)
		return ($0 "\n")
	else if (0 == _res)
		return ""

	error_quit(sprintf("getline io with code %s", _res))
}
function lex_usr_on_unknown_ch() {
	_lu_errq_pos(sprintf("unknown character '%s'", lex_curr_ch()))
}
function lex_usr_on_comment() {
	if (lex_read_line())
		return lex_next()
	else
		return TOK_EOI()
}

function _lu_is_upped(ch) {return (ch >= "A" && ch <= "Z")}
function _lu_is_lower(ch) {return (ch >= "a" && ch <= "z")}
function _lu_is_digit(ch) {return (ch >= "0" && ch <= "9")}
function _lu_is_name_part(ch) {return "_" == ch || _lu_is_digit(ch)}
function _lu_is_term_rest(ch) {return _lu_is_upped(ch) || _lu_is_name_part(ch)}
function _lu_is_nont_rest(ch) {return _lu_is_lower(ch) || _lu_is_name_part(ch)}

function _lu_errq_pos(msg) {
	error_quit(sprintf("%s: %s\n%s", _lu_pos(), msg, lex_get_pos_str()))
}
function _lu_pos() {
	return sprintf("file %s, line %d, pos %d", \
		fname(), lex_get_line_no(), lex_get_pos())
}

function lex_usr_get_word(    _ch) {
	lex_save_init()

	if (_lu_is_name_part(_ch = lex_curr_ch())) {
		lex_save_curr_ch()
		while (_lu_is_name_part(_ch = lex_peek_ch())) {
			lex_read_ch()
			lex_save_curr_ch()
		}

		if (!_lu_is_upped(_ch) && !_lu_is_lower(_ch))
			_lu_errq_pos(sprintf("name must contain at least one letter"))
		else
			lex_read_ch()
	}

	if (_lu_is_upped(_ch))
		return _get_term()
	else if (_lu_is_lower(_ch))
		return _get_nont()
	else
		return TOK_ERROR()
}

function _get_term(    _ch) {
	while (1) {
		lex_save_curr_ch()
		_ch = lex_peek_ch()
		if (_lu_is_term_rest(_ch))
			lex_read_ch()
		else
			break
	}

	if (lex_is_next_ch_cls(CH_CLS_WORD())) {
		lex_read_ch()
		_lu_errq_pos("non-upper case in a terminal symbol")
	}

	return TERM()
}

function _get_nont(    _ch) {
	while (1) {
		lex_save_curr_ch()
		_ch = lex_peek_ch()
		if (_lu_is_nont_rest(_ch))
			lex_read_ch()
		else
			break
	}

	if (lex_is_next_ch_cls(CH_CLS_WORD())) {
		lex_read_ch()
		_lu_errq_pos("non-lower case in a non-terminal symbol")
	}

	return (!lex_is_saved_a_keyword() ? NONT() : lex_get_saved())
}
# </lex_usr>
# </lexer>
# <prs>
# <parse>
#
# translated by rdpg-to-awk.awk 2.0.1
# generated by rdpg-comp.awk 2.0.2
# 
# Grammar:
# 
# 1. start : grmr_defn_opt TOK_EOI
# 
# 2. grmr_defn : start_defn lhs_defn_plus
# 
# 3. grmr_defn_opt : grmr_defn
# 4. grmr_defn_opt : 0
# 
# 5. start_defn : START_SYM COLON NONT \on_top_sym nont_mod_opt TERM \on_eoi_term SEMI
# 
# 6. lhs_defn : NONT \on_lhs_start COLON rule bar_rule_star SEMI
# 
# 7. lhs_defn_plus : lhs_defn lhs_defn_star
# 
# 8. lhs_defn_star : lhs_defn lhs_defn_star
# 9. lhs_defn_star : 0
# 
# 10. rule : \on_rule_start esc_star sym_plus
# 
# 11. bar_rule : BAR rule
# 
# 12. bar_rule_star : bar_rule bar_rule_star
# 13. bar_rule_star : 0
# 
# 14. sym : grmr_sym esc_star
# 
# 15. sym_plus : sym sym_star
# 
# 16. sym_star : sym sym_star
# 17. sym_star : 0
# 
# 18. esc : ESC NONT \on_esc
# 
# 19. esc_star : esc esc_star
# 20. esc_star : 0
# 
# 21. grmr_sym : TERM \on_term
# 22. grmr_sym : NONT \on_nont nont_mod_opt
# 
# 23. nont_mod : QMARK \on_qmark
# 24. nont_mod : STAR \on_star
# 25. nont_mod : PLUS \on_plus
# 
# 26. nont_mod_opt : nont_mod
# 27. nont_mod_opt : 0
# 

# <public>
function rdpg_parse()
{
	_rdpg_init_sets()
	return _rdpg_start() && !_RDPG_had_error
}
function rdpg_expect(arr_out,    _len) {
	delete arr_out
	if ("tok" == _RDPG_expect_type)
		arr_out[(_len = 1)] = _RDPG_expect_what
	else if ("set" == _RDPG_expect_type)
		_len = split(_RDPG_expect_sets[_RDPG_expect_what], arr_out, _RDPG_SEP())
	return _len
}
# </public>
# <internal>
function _RDPG_SEP() {return "\034"}
function _rdpg_tok_next() {
	tok_next()
	_RDPG_curr_tok = tok_curr()
}
function _rdpg_tok_is(tok) {
	return (tok == _RDPG_curr_tok)
}
function _rdpg_tok_match(tok,    _ret) {
	if (_ret = _rdpg_tok_is(tok))
		_rdpg_tok_next()
	return _ret
}
function _rdpg_init_sets(    _i, _len, _arr) {
	# alias
	_RDPG_B_str_sym_set_1 = (TOK_EOI() _RDPG_SEP() START_SYM())
	_RDPG_B_str_sym_set_2 = (ESC() _RDPG_SEP() TERM() _RDPG_SEP() NONT())
	_RDPG_B_str_sym_set_3 = (TERM() _RDPG_SEP() NONT())
	_RDPG_B_str_sym_set_4 = (BAR() _RDPG_SEP() SEMI())
	_RDPG_B_str_sym_set_5 = (TERM() _RDPG_SEP() NONT() _RDPG_SEP() BAR() _RDPG_SEP() SEMI())
	_RDPG_B_str_sym_set_6 = (QMARK() _RDPG_SEP() STAR() _RDPG_SEP() PLUS())
	_RDPG_B_str_sym_set_7 = (TERM() _RDPG_SEP() ESC() _RDPG_SEP() NONT() _RDPG_SEP() BAR() _RDPG_SEP() SEMI())
	_RDPG_B_str_sym_set_8 = (START_SYM() _RDPG_SEP() TOK_EOI())
	_RDPG_B_str_sym_set_9 = (NONT() _RDPG_SEP() TOK_EOI())
	_RDPG_B_str_sym_set_10 = (ESC() _RDPG_SEP() TERM() _RDPG_SEP() NONT() _RDPG_SEP() BAR() _RDPG_SEP() SEMI())
	_RDPG_B_str_sym_set_11 = (QMARK() _RDPG_SEP() STAR() _RDPG_SEP() PLUS() _RDPG_SEP() TERM() _RDPG_SEP() ESC() _RDPG_SEP() NONT() _RDPG_SEP() BAR() _RDPG_SEP() SEMI())
	_RDPG_B_str_sym_set_12 = (TOK_EOI())
	_RDPG_B_str_sym_set_13 = (NONT())
	_RDPG_B_str_sym_set_14 = (SEMI())

	_len = split(_RDPG_B_str_sym_set_1, _arr, _RDPG_SEP())
	for (_i = 1; _i <= _len; ++_i)
		_RDPG_sym_set_1[_arr[_i]]

	_len = split(_RDPG_B_str_sym_set_2, _arr, _RDPG_SEP())
	for (_i = 1; _i <= _len; ++_i)
		_RDPG_sym_set_2[_arr[_i]]

	_len = split(_RDPG_B_str_sym_set_3, _arr, _RDPG_SEP())
	for (_i = 1; _i <= _len; ++_i)
		_RDPG_sym_set_3[_arr[_i]]

	_len = split(_RDPG_B_str_sym_set_4, _arr, _RDPG_SEP())
	for (_i = 1; _i <= _len; ++_i)
		_RDPG_sym_set_4[_arr[_i]]

	_len = split(_RDPG_B_str_sym_set_5, _arr, _RDPG_SEP())
	for (_i = 1; _i <= _len; ++_i)
		_RDPG_sym_set_5[_arr[_i]]

	_len = split(_RDPG_B_str_sym_set_6, _arr, _RDPG_SEP())
	for (_i = 1; _i <= _len; ++_i)
		_RDPG_sym_set_6[_arr[_i]]

	_len = split(_RDPG_B_str_sym_set_7, _arr, _RDPG_SEP())
	for (_i = 1; _i <= _len; ++_i)
		_RDPG_sym_set_7[_arr[_i]]

	_len = split(_RDPG_B_str_sym_set_8, _arr, _RDPG_SEP())
	for (_i = 1; _i <= _len; ++_i)
		_RDPG_sym_set_8[_arr[_i]]

	_len = split(_RDPG_B_str_sym_set_9, _arr, _RDPG_SEP())
	for (_i = 1; _i <= _len; ++_i)
		_RDPG_sym_set_9[_arr[_i]]

	_len = split(_RDPG_B_str_sym_set_10, _arr, _RDPG_SEP())
	for (_i = 1; _i <= _len; ++_i)
		_RDPG_sym_set_10[_arr[_i]]

	_len = split(_RDPG_B_str_sym_set_11, _arr, _RDPG_SEP())
	for (_i = 1; _i <= _len; ++_i)
		_RDPG_sym_set_11[_arr[_i]]

	_len = split(_RDPG_B_str_sym_set_12, _arr, _RDPG_SEP())
	for (_i = 1; _i <= _len; ++_i)
		_RDPG_sym_set_12[_arr[_i]]

	_len = split(_RDPG_B_str_sym_set_13, _arr, _RDPG_SEP())
	for (_i = 1; _i <= _len; ++_i)
		_RDPG_sym_set_13[_arr[_i]]

	_len = split(_RDPG_B_str_sym_set_14, _arr, _RDPG_SEP())
	for (_i = 1; _i <= _len; ++_i)
		_RDPG_sym_set_14[_arr[_i]]

	# expect
	_RDPG_expect_sets["start"] = _RDPG_B_str_sym_set_1
	_RDPG_expect_sets["grmr_defn_opt"] = _RDPG_B_str_sym_set_8
	_RDPG_expect_sets["lhs_defn_star"] = _RDPG_B_str_sym_set_9
	_RDPG_expect_sets["rule"] = _RDPG_B_str_sym_set_2
	_RDPG_expect_sets["bar_rule_star"] = _RDPG_B_str_sym_set_4
	_RDPG_expect_sets["sym"] = _RDPG_B_str_sym_set_3
	_RDPG_expect_sets["sym_plus"] = _RDPG_B_str_sym_set_3
	_RDPG_expect_sets["sym_star"] = _RDPG_B_str_sym_set_5
	_RDPG_expect_sets["esc_star"] = _RDPG_B_str_sym_set_10
	_RDPG_expect_sets["grmr_sym"] = _RDPG_B_str_sym_set_3
	_RDPG_expect_sets["nont_mod"] = _RDPG_B_str_sym_set_6
	_RDPG_expect_sets["nont_mod_opt"] = _RDPG_B_str_sym_set_11
}
function _rdpg_predict(set) {
	return (_RDPG_curr_tok in set)
}
function _rdpg_sync(set) {
	while (_RDPG_curr_tok) {
		if (_RDPG_curr_tok in set)
			return 1
		if (_rdpg_tok_is(TOK_EOI()))
			break
		_rdpg_tok_next()
	}
	return 0
}
function _rdpg_expect(type, what) {
	_RDPG_expect_type = type
	_RDPG_expect_what = what
	_RDPG_had_error = 1
	tok_err()
}
# </internal>
# <rd>
function _rdpg_start()
{
	# 1. start : grmr_defn_opt TOK_EOI

	_rdpg_tok_next()
	if (_rdpg_predict(_RDPG_sym_set_1))
	{
		if (_rdpg_grmr_defn_opt())
		{
			if (_rdpg_tok_match(TOK_EOI()))
			{
				return 1
			}
			else
			{
				_rdpg_expect("tok", TOK_EOI())
			}
		}
	}
	else
	{
		_rdpg_expect("set", "start")
	}
	return 0
}
function _rdpg_grmr_defn()
{
	# 2. grmr_defn : start_defn lhs_defn_plus

	if (_rdpg_tok_is(START_SYM()))
	{
		if (_rdpg_start_defn())
		{
			if (_rdpg_lhs_defn_plus())
			{
				return 1
			}
		}
	}
	else
	{
		_rdpg_expect("tok", START_SYM())
	}
	return _rdpg_sync(_RDPG_sym_set_12)
}
function _rdpg_grmr_defn_opt()
{
	# 3. grmr_defn_opt : grmr_defn
	# 4. grmr_defn_opt : 0

	if (_rdpg_tok_is(START_SYM()))
	{
		if (_rdpg_grmr_defn())
		{
			return 1
		}
	}
	else if (_rdpg_tok_is(TOK_EOI()))
	{
		return 1
	}
	else
	{
		_rdpg_expect("set", "grmr_defn_opt")
	}
	return _rdpg_sync(_RDPG_sym_set_12)
}
function _rdpg_start_defn()
{
	# 5. start_defn : START_SYM COLON NONT \on_top_sym nont_mod_opt TERM \on_eoi_term SEMI

	if (_rdpg_tok_match(START_SYM()))
	{
		if (_rdpg_tok_match(COLON()))
		{
			if (_rdpg_tok_is(NONT()))
			{
				on_top_sym()
				_rdpg_tok_next()
				if (_rdpg_nont_mod_opt())
				{
					if (_rdpg_tok_is(TERM()))
					{
						on_eoi_term()
						_rdpg_tok_next()
						if (_rdpg_tok_match(SEMI()))
						{
							return 1
						}
						else
						{
							_rdpg_expect("tok", SEMI())
						}
					}
					else
					{
						_rdpg_expect("tok", TERM())
					}
				}
			}
			else
			{
				_rdpg_expect("tok", NONT())
			}
		}
		else
		{
			_rdpg_expect("tok", COLON())
		}
	}
	else
	{
		_rdpg_expect("tok", START_SYM())
	}
	return _rdpg_sync(_RDPG_sym_set_13)
}
function _rdpg_lhs_defn()
{
	# 6. lhs_defn : NONT \on_lhs_start COLON rule bar_rule_star SEMI

	if (_rdpg_tok_is(NONT()))
	{
		on_lhs_start()
		_rdpg_tok_next()
		if (_rdpg_tok_match(COLON()))
		{
			if (_rdpg_rule())
			{
				if (_rdpg_bar_rule_star())
				{
					if (_rdpg_tok_match(SEMI()))
					{
						return 1
					}
					else
					{
						_rdpg_expect("tok", SEMI())
					}
				}
			}
		}
		else
		{
			_rdpg_expect("tok", COLON())
		}
	}
	else
	{
		_rdpg_expect("tok", NONT())
	}
	return _rdpg_sync(_RDPG_sym_set_9)
}
function _rdpg_lhs_defn_plus()
{
	# 7. lhs_defn_plus : lhs_defn lhs_defn_star

	if (_rdpg_tok_is(NONT()))
	{
		if (_rdpg_lhs_defn())
		{
			if (_rdpg_lhs_defn_star())
			{
				return 1
			}
		}
	}
	else
	{
		_rdpg_expect("tok", NONT())
	}
	return _rdpg_sync(_RDPG_sym_set_12)
}
function _rdpg_lhs_defn_star()
{
	# 8. lhs_defn_star : lhs_defn lhs_defn_star
	# 9. lhs_defn_star : 0

	while (1)
	{
		if (_rdpg_tok_is(NONT()))
		{
			if (_rdpg_lhs_defn())
			{
				continue
			}
		}
		else if (_rdpg_tok_is(TOK_EOI()))
		{
			return 1
		}
		else
		{
			_rdpg_expect("set", "lhs_defn_star")
		}
		return _rdpg_sync(_RDPG_sym_set_12)
	}
}
function _rdpg_rule()
{
	# 10. rule : \on_rule_start esc_star sym_plus

	if (_rdpg_predict(_RDPG_sym_set_2))
	{
		on_rule_start()
		if (_rdpg_esc_star())
		{
			if (_rdpg_sym_plus())
			{
				return 1
			}
		}
	}
	else
	{
		_rdpg_expect("set", "rule")
	}
	return _rdpg_sync(_RDPG_sym_set_4)
}
function _rdpg_bar_rule()
{
	# 11. bar_rule : BAR rule

	if (_rdpg_tok_match(BAR()))
	{
		if (_rdpg_rule())
		{
			return 1
		}
	}
	else
	{
		_rdpg_expect("tok", BAR())
	}
	return _rdpg_sync(_RDPG_sym_set_4)
}
function _rdpg_bar_rule_star()
{
	# 12. bar_rule_star : bar_rule bar_rule_star
	# 13. bar_rule_star : 0

	while (1)
	{
		if (_rdpg_tok_is(BAR()))
		{
			if (_rdpg_bar_rule())
			{
				continue
			}
		}
		else if (_rdpg_tok_is(SEMI()))
		{
			return 1
		}
		else
		{
			_rdpg_expect("set", "bar_rule_star")
		}
		return _rdpg_sync(_RDPG_sym_set_14)
	}
}
function _rdpg_sym()
{
	# 14. sym : grmr_sym esc_star

	if (_rdpg_predict(_RDPG_sym_set_3))
	{
		if (_rdpg_grmr_sym())
		{
			if (_rdpg_esc_star())
			{
				return 1
			}
		}
	}
	else
	{
		_rdpg_expect("set", "sym")
	}
	return _rdpg_sync(_RDPG_sym_set_5)
}
function _rdpg_sym_plus()
{
	# 15. sym_plus : sym sym_star

	if (_rdpg_predict(_RDPG_sym_set_3))
	{
		if (_rdpg_sym())
		{
			if (_rdpg_sym_star())
			{
				return 1
			}
		}
	}
	else
	{
		_rdpg_expect("set", "sym_plus")
	}
	return _rdpg_sync(_RDPG_sym_set_4)
}
function _rdpg_sym_star()
{
	# 16. sym_star : sym sym_star
	# 17. sym_star : 0

	while (1)
	{
		if (_rdpg_predict(_RDPG_sym_set_3))
		{
			if (_rdpg_sym())
			{
				continue
			}
		}
		else if (_rdpg_predict(_RDPG_sym_set_4))
		{
			return 1
		}
		else
		{
			_rdpg_expect("set", "sym_star")
		}
		return _rdpg_sync(_RDPG_sym_set_4)
	}
}
function _rdpg_esc()
{
	# 18. esc : ESC NONT \on_esc

	if (_rdpg_tok_match(ESC()))
	{
		if (_rdpg_tok_is(NONT()))
		{
			on_esc()
			_rdpg_tok_next()
			return 1
		}
		else
		{
			_rdpg_expect("tok", NONT())
		}
	}
	else
	{
		_rdpg_expect("tok", ESC())
	}
	return _rdpg_sync(_RDPG_sym_set_10)
}
function _rdpg_esc_star()
{
	# 19. esc_star : esc esc_star
	# 20. esc_star : 0

	while (1)
	{
		if (_rdpg_tok_is(ESC()))
		{
			if (_rdpg_esc())
			{
				continue
			}
		}
		else if (_rdpg_predict(_RDPG_sym_set_5))
		{
			return 1
		}
		else
		{
			_rdpg_expect("set", "esc_star")
		}
		return _rdpg_sync(_RDPG_sym_set_5)
	}
}
function _rdpg_grmr_sym()
{
	# 21. grmr_sym : TERM \on_term
	# 22. grmr_sym : NONT \on_nont nont_mod_opt

	if (_rdpg_tok_is(TERM()))
	{
		on_term()
		_rdpg_tok_next()
		return 1
	}
	else if (_rdpg_tok_is(NONT()))
	{
		on_nont()
		_rdpg_tok_next()
		if (_rdpg_nont_mod_opt())
		{
			return 1
		}
	}
	else
	{
		_rdpg_expect("set", "grmr_sym")
	}
	return _rdpg_sync(_RDPG_sym_set_10)
}
function _rdpg_nont_mod()
{
	# 23. nont_mod : QMARK \on_qmark
	# 24. nont_mod : STAR \on_star
	# 25. nont_mod : PLUS \on_plus

	if (_rdpg_tok_is(QMARK()))
	{
		on_qmark()
		_rdpg_tok_next()
		return 1
	}
	else if (_rdpg_tok_is(STAR()))
	{
		on_star()
		_rdpg_tok_next()
		return 1
	}
	else if (_rdpg_tok_is(PLUS()))
	{
		on_plus()
		_rdpg_tok_next()
		return 1
	}
	else
	{
		_rdpg_expect("set", "nont_mod")
	}
	return _rdpg_sync(_RDPG_sym_set_7)
}
function _rdpg_nont_mod_opt()
{
	# 26. nont_mod_opt : nont_mod
	# 27. nont_mod_opt : 0

	if (_rdpg_predict(_RDPG_sym_set_6))
	{
		if (_rdpg_nont_mod())
		{
			return 1
		}
	}
	else if (_rdpg_predict(_RDPG_sym_set_7))
	{
		return 1
	}
	else
	{
		_rdpg_expect("set", "nont_mod_opt")
	}
	return _rdpg_sync(_RDPG_sym_set_7)
}
# </rd>
# </parse>
# <dispatch>
function on_top_sym()    {_prs_do("on_top_sym")}
function on_eoi_term()   {_prs_do("on_eoi_term")}
function on_lhs_start()  {_prs_do("on_lhs_start")}
function on_rule_start() {_prs_do("on_rule_start")}
function on_esc()        {_prs_do("on_esc")}
function on_term()       {_prs_do("on_term")}
function on_nont()       {_prs_do("on_nont")}
function on_qmark()      {_prs_do("on_qmark")}
function on_star()       {_prs_do("on_star")}
function on_plus()       {_prs_do("on_plus")}

function _prs_do(what) {
	if (parsing_error_happened())     return
	else if ("on_top_sym"    == what) _prs_on_start(lex_get_saved())
	else if ("on_eoi_term"   == what) _prs_start_set_eoi_term(lex_get_saved())
	else if ("on_lhs_start"  == what) _prs_on_lhs(lex_get_saved())
	else if ("on_rule_start" == what) _prs_on_rule()
	else if ("on_esc"        == what) _prs_on_esc(lex_get_saved())
	else if ("on_term"       == what) _prs_on_sym(TERM(), lex_get_saved())
	else if ("on_nont"       == what) _prs_on_sym(NONT(), lex_get_saved())
	else if ("on_qmark"      == what) _prs_on_mod(QMARK())
	else if ("on_star"       == what) _prs_on_mod(STAR())
	else if ("on_plus"       == what) _prs_on_mod(PLUS())
	else error_quit(sprintf("parser: unknown actions '%s'", what))
}
# </dispatch>

# <process>
function _prs_esc_type_set(type) {_B_prs_esc_type = type}
function _prs_esc_type()         {return _B_prs_esc_type}
function _prs_mod_type_set(type) {_B_prs_mod_type = type}
function _prs_mod_type()         {return _B_prs_mod_type}
# <ast-wrapper>
function _prs_set_start(ent) {ast_root_set(ent)}
function _prs_get_start() {return ast_root()}

function _prs_set_top_lhs(ent) {ast_start_push_lhs(_prs_get_start(), ent)}
function _prs_get_top_lhs() {return ast_start_last_lhs(_prs_get_start())}

function _prs_set_top_rule(ent) {ast_lhs_push_rule(_prs_get_top_lhs(), ent)}
function _prs_get_top_rule() {return ast_lhs_last_rule(_prs_get_top_lhs())}

function _prs_set_top_sym(ent) {ast_rule_push_sym(_prs_get_top_rule(), ent)}
function _prs_get_top_sym() {return ast_rule_last_sym(_prs_get_top_rule())}

function _prs_set_rule_top_esc(ent) {
	ast_rule_push_esc(_prs_get_top_rule(), ent)
}
function _prs_get_rule_top_esc() {return ast_rule_last_esc(_prs_get_top_rule())}

function _prs_set_sym_top_esc(ent) {ast_sym_push_esc(_prs_get_top_sym(), ent)}
function _prs_get_sym_top_esc() {return ast_sym_last_esc(_prs_get_top_sym())}

function _prs_on_start(nont) {
	_prs_set_start(ast_start_create(nont))
	_prs_mod_type_set(AST_START())
}
function _prs_start_set_eoi_term(term) {
	ast_start_set_eoi_term(_prs_get_start(), term)
}
function _prs_on_lhs(name) {
	_prs_set_top_lhs(ast_lhs_create(name))
}
function _prs_on_rule() {
	_prs_set_top_rule(ast_rule_create())
	_prs_esc_type_set(AST_RULE())
}
function _prs_on_sym(type, name) {
	_prs_set_top_sym(ast_sym_create(type, name))
	_prs_esc_type_set(AST_SYM())
	_prs_mod_type_set(AST_SYM())
}
function _prs_on_esc(name,    _esc, _type) {
	_esc = ast_esc_create(name)
	_type = _prs_esc_type()
	if (AST_RULE() == _type)
		_prs_set_rule_top_esc(_esc)
	else if (AST_SYM() == _type)
		_prs_set_sym_top_esc(_esc)
}
function _prs_on_mod(mod,    _type) {
	_type = _prs_mod_type()
	if (AST_START() == _type)
		ast_start_set_mod(_prs_get_start(), mod)
	else if (AST_SYM() == _type)
		ast_sym_set_mod(_prs_get_top_sym(), mod)
}
# </ast-wrapper>
# </process>
# </prs>
# <ast>
# <structs-ast>
# structs:
#
# prefix ast
#
# type start
# has  top_nont 
# has  mod 
# has  eoi_term 
# has  line_num 
# has  lhs_lst lhs_lst
#
# type lhs_lst
# has  head lhs
# has  tail lhs
#
# type lhs
# has  name 
# has  line_num 
# has  rule_lst rule_lst
# has  next_ lhs
#
# type rule_lst
# has  head rule
# has  tail rule
#
# type rule
# has  esc_lst esc_lst
# has  sym_lst sym_lst
# has  next_ rule
#
# type sym_lst
# has  head sym
# has  tail sym
#
# type sym
# has  type 
# has  name 
# has  mod 
# has  esc_lst esc_lst
# has  next_ sym
#
# type esc_lst
# has  head esc
# has  tail esc
#
# type esc
# has  name 
# has  next_ esc
#
# <private>
function _ast_set(k, v) {_STRUCTS_ast_db[k] = v}
function _ast_get(k) {return _STRUCTS_ast_db[k]}
function _ast_type_chk(ent, texp) {
	if (ast_type_of(ent) == texp)
		return
	ast_errq(sprintf("entity '%s' expected type '%s', actual type '%s'", \
		 ent, texp, ast_type_of(ent)))
}
# <\private>

function ast_clear() {
	delete _STRUCTS_ast_db
	_ent_set("gen", _ent_get("gen")+1)
}
function ast_is(ent) {return (ent in _STRUCTS_ast_db)}
function ast_type_of(ent) {
	if (ent in _STRUCTS_ast_db)
		return _STRUCTS_ast_db[ent]
	ast_errq(sprintf("'%s' not an entity", ent))
}
function ast_new(type,    _ent) {
	_ast_set("ents", (_ent = _ast_get("ents")+1))
	_ent = ("_ast-" _ast_get("gen")+0 "-" _ent)
	_ast_set(_ent, type)
	return _ent
}
# <types>
# <type-start>
function AST_START() {return "start"}

function ast_start_make(top_nont, mod, eoi_term, line_num, lhs_lst,     _ent) {
	_ent = ast_new("start")
	ast_start_set_top_nont(_ent, top_nont)
	ast_start_set_mod(_ent, mod)
	ast_start_set_eoi_term(_ent, eoi_term)
	ast_start_set_line_num(_ent, line_num)
	ast_start_set_lhs_lst(_ent, lhs_lst)
	return _ent
}

function ast_start_set_top_nont(ent, top_nont) {
	_ast_type_chk(ent, "start")
	_ast_set(("top_nont=" ent), top_nont)
}
function ast_start_get_top_nont(ent) {
	_ast_type_chk(ent, "start")
	return _ast_get(("top_nont=" ent))
}

function ast_start_set_mod(ent, mod) {
	_ast_type_chk(ent, "start")
	_ast_set(("mod=" ent), mod)
}
function ast_start_get_mod(ent) {
	_ast_type_chk(ent, "start")
	return _ast_get(("mod=" ent))
}

function ast_start_set_eoi_term(ent, eoi_term) {
	_ast_type_chk(ent, "start")
	_ast_set(("eoi_term=" ent), eoi_term)
}
function ast_start_get_eoi_term(ent) {
	_ast_type_chk(ent, "start")
	return _ast_get(("eoi_term=" ent))
}

function ast_start_set_line_num(ent, line_num) {
	_ast_type_chk(ent, "start")
	_ast_set(("line_num=" ent), line_num)
}
function ast_start_get_line_num(ent) {
	_ast_type_chk(ent, "start")
	return _ast_get(("line_num=" ent))
}

function ast_start_set_lhs_lst(ent, lhs_lst) {
	_ast_type_chk(ent, "start")
	if (lhs_lst)
		_ast_type_chk(lhs_lst, "lhs_lst")
	_ast_set(("lhs_lst=" ent), lhs_lst)
}
function ast_start_get_lhs_lst(ent) {
	_ast_type_chk(ent, "start")
	return _ast_get(("lhs_lst=" ent))
}

# <\type-start>
# <type-lhs_lst>
function AST_LHS_LST() {return "lhs_lst"}

function ast_lhs_lst_make(head, tail,     _ent) {
	_ent = ast_new("lhs_lst")
	ast_lhs_lst_set_head(_ent, head)
	ast_lhs_lst_set_tail(_ent, tail)
	return _ent
}

function ast_lhs_lst_set_head(ent, head) {
	_ast_type_chk(ent, "lhs_lst")
	if (head)
		_ast_type_chk(head, "lhs")
	_ast_set(("head=" ent), head)
}
function ast_lhs_lst_get_head(ent) {
	_ast_type_chk(ent, "lhs_lst")
	return _ast_get(("head=" ent))
}

function ast_lhs_lst_set_tail(ent, tail) {
	_ast_type_chk(ent, "lhs_lst")
	if (tail)
		_ast_type_chk(tail, "lhs")
	_ast_set(("tail=" ent), tail)
}
function ast_lhs_lst_get_tail(ent) {
	_ast_type_chk(ent, "lhs_lst")
	return _ast_get(("tail=" ent))
}

# <\type-lhs_lst>
# <type-lhs>
function AST_LHS() {return "lhs"}

function ast_lhs_make(name, line_num, rule_lst, next_,     _ent) {
	_ent = ast_new("lhs")
	ast_lhs_set_name(_ent, name)
	ast_lhs_set_line_num(_ent, line_num)
	ast_lhs_set_rule_lst(_ent, rule_lst)
	ast_lhs_set_next_(_ent, next_)
	return _ent
}

function ast_lhs_set_name(ent, name) {
	_ast_type_chk(ent, "lhs")
	_ast_set(("name=" ent), name)
}
function ast_lhs_get_name(ent) {
	_ast_type_chk(ent, "lhs")
	return _ast_get(("name=" ent))
}

function ast_lhs_set_line_num(ent, line_num) {
	_ast_type_chk(ent, "lhs")
	_ast_set(("line_num=" ent), line_num)
}
function ast_lhs_get_line_num(ent) {
	_ast_type_chk(ent, "lhs")
	return _ast_get(("line_num=" ent))
}

function ast_lhs_set_rule_lst(ent, rule_lst) {
	_ast_type_chk(ent, "lhs")
	if (rule_lst)
		_ast_type_chk(rule_lst, "rule_lst")
	_ast_set(("rule_lst=" ent), rule_lst)
}
function ast_lhs_get_rule_lst(ent) {
	_ast_type_chk(ent, "lhs")
	return _ast_get(("rule_lst=" ent))
}

function ast_lhs_set_next_(ent, next_) {
	_ast_type_chk(ent, "lhs")
	if (next_)
		_ast_type_chk(next_, "lhs")
	_ast_set(("next_=" ent), next_)
}
function ast_lhs_get_next_(ent) {
	_ast_type_chk(ent, "lhs")
	return _ast_get(("next_=" ent))
}

# <\type-lhs>
# <type-rule_lst>
function AST_RULE_LST() {return "rule_lst"}

function ast_rule_lst_make(head, tail,     _ent) {
	_ent = ast_new("rule_lst")
	ast_rule_lst_set_head(_ent, head)
	ast_rule_lst_set_tail(_ent, tail)
	return _ent
}

function ast_rule_lst_set_head(ent, head) {
	_ast_type_chk(ent, "rule_lst")
	if (head)
		_ast_type_chk(head, "rule")
	_ast_set(("head=" ent), head)
}
function ast_rule_lst_get_head(ent) {
	_ast_type_chk(ent, "rule_lst")
	return _ast_get(("head=" ent))
}

function ast_rule_lst_set_tail(ent, tail) {
	_ast_type_chk(ent, "rule_lst")
	if (tail)
		_ast_type_chk(tail, "rule")
	_ast_set(("tail=" ent), tail)
}
function ast_rule_lst_get_tail(ent) {
	_ast_type_chk(ent, "rule_lst")
	return _ast_get(("tail=" ent))
}

# <\type-rule_lst>
# <type-rule>
function AST_RULE() {return "rule"}

function ast_rule_make(esc_lst, sym_lst, next_,     _ent) {
	_ent = ast_new("rule")
	ast_rule_set_esc_lst(_ent, esc_lst)
	ast_rule_set_sym_lst(_ent, sym_lst)
	ast_rule_set_next_(_ent, next_)
	return _ent
}

function ast_rule_set_esc_lst(ent, esc_lst) {
	_ast_type_chk(ent, "rule")
	if (esc_lst)
		_ast_type_chk(esc_lst, "esc_lst")
	_ast_set(("esc_lst=" ent), esc_lst)
}
function ast_rule_get_esc_lst(ent) {
	_ast_type_chk(ent, "rule")
	return _ast_get(("esc_lst=" ent))
}

function ast_rule_set_sym_lst(ent, sym_lst) {
	_ast_type_chk(ent, "rule")
	if (sym_lst)
		_ast_type_chk(sym_lst, "sym_lst")
	_ast_set(("sym_lst=" ent), sym_lst)
}
function ast_rule_get_sym_lst(ent) {
	_ast_type_chk(ent, "rule")
	return _ast_get(("sym_lst=" ent))
}

function ast_rule_set_next_(ent, next_) {
	_ast_type_chk(ent, "rule")
	if (next_)
		_ast_type_chk(next_, "rule")
	_ast_set(("next_=" ent), next_)
}
function ast_rule_get_next_(ent) {
	_ast_type_chk(ent, "rule")
	return _ast_get(("next_=" ent))
}

# <\type-rule>
# <type-sym_lst>
function AST_SYM_LST() {return "sym_lst"}

function ast_sym_lst_make(head, tail,     _ent) {
	_ent = ast_new("sym_lst")
	ast_sym_lst_set_head(_ent, head)
	ast_sym_lst_set_tail(_ent, tail)
	return _ent
}

function ast_sym_lst_set_head(ent, head) {
	_ast_type_chk(ent, "sym_lst")
	if (head)
		_ast_type_chk(head, "sym")
	_ast_set(("head=" ent), head)
}
function ast_sym_lst_get_head(ent) {
	_ast_type_chk(ent, "sym_lst")
	return _ast_get(("head=" ent))
}

function ast_sym_lst_set_tail(ent, tail) {
	_ast_type_chk(ent, "sym_lst")
	if (tail)
		_ast_type_chk(tail, "sym")
	_ast_set(("tail=" ent), tail)
}
function ast_sym_lst_get_tail(ent) {
	_ast_type_chk(ent, "sym_lst")
	return _ast_get(("tail=" ent))
}

# <\type-sym_lst>
# <type-sym>
function AST_SYM() {return "sym"}

function ast_sym_make(type, name, mod, esc_lst, next_,     _ent) {
	_ent = ast_new("sym")
	ast_sym_set_type(_ent, type)
	ast_sym_set_name(_ent, name)
	ast_sym_set_mod(_ent, mod)
	ast_sym_set_esc_lst(_ent, esc_lst)
	ast_sym_set_next_(_ent, next_)
	return _ent
}

function ast_sym_set_type(ent, type) {
	_ast_type_chk(ent, "sym")
	_ast_set(("type=" ent), type)
}
function ast_sym_get_type(ent) {
	_ast_type_chk(ent, "sym")
	return _ast_get(("type=" ent))
}

function ast_sym_set_name(ent, name) {
	_ast_type_chk(ent, "sym")
	_ast_set(("name=" ent), name)
}
function ast_sym_get_name(ent) {
	_ast_type_chk(ent, "sym")
	return _ast_get(("name=" ent))
}

function ast_sym_set_mod(ent, mod) {
	_ast_type_chk(ent, "sym")
	_ast_set(("mod=" ent), mod)
}
function ast_sym_get_mod(ent) {
	_ast_type_chk(ent, "sym")
	return _ast_get(("mod=" ent))
}

function ast_sym_set_esc_lst(ent, esc_lst) {
	_ast_type_chk(ent, "sym")
	if (esc_lst)
		_ast_type_chk(esc_lst, "esc_lst")
	_ast_set(("esc_lst=" ent), esc_lst)
}
function ast_sym_get_esc_lst(ent) {
	_ast_type_chk(ent, "sym")
	return _ast_get(("esc_lst=" ent))
}

function ast_sym_set_next_(ent, next_) {
	_ast_type_chk(ent, "sym")
	if (next_)
		_ast_type_chk(next_, "sym")
	_ast_set(("next_=" ent), next_)
}
function ast_sym_get_next_(ent) {
	_ast_type_chk(ent, "sym")
	return _ast_get(("next_=" ent))
}

# <\type-sym>
# <type-esc_lst>
function AST_ESC_LST() {return "esc_lst"}

function ast_esc_lst_make(head, tail,     _ent) {
	_ent = ast_new("esc_lst")
	ast_esc_lst_set_head(_ent, head)
	ast_esc_lst_set_tail(_ent, tail)
	return _ent
}

function ast_esc_lst_set_head(ent, head) {
	_ast_type_chk(ent, "esc_lst")
	if (head)
		_ast_type_chk(head, "esc")
	_ast_set(("head=" ent), head)
}
function ast_esc_lst_get_head(ent) {
	_ast_type_chk(ent, "esc_lst")
	return _ast_get(("head=" ent))
}

function ast_esc_lst_set_tail(ent, tail) {
	_ast_type_chk(ent, "esc_lst")
	if (tail)
		_ast_type_chk(tail, "esc")
	_ast_set(("tail=" ent), tail)
}
function ast_esc_lst_get_tail(ent) {
	_ast_type_chk(ent, "esc_lst")
	return _ast_get(("tail=" ent))
}

# <\type-esc_lst>
# <type-esc>
function AST_ESC() {return "esc"}

function ast_esc_make(name, next_,     _ent) {
	_ent = ast_new("esc")
	ast_esc_set_name(_ent, name)
	ast_esc_set_next_(_ent, next_)
	return _ent
}

function ast_esc_set_name(ent, name) {
	_ast_type_chk(ent, "esc")
	_ast_set(("name=" ent), name)
}
function ast_esc_get_name(ent) {
	_ast_type_chk(ent, "esc")
	return _ast_get(("name=" ent))
}

function ast_esc_set_next_(ent, next_) {
	_ast_type_chk(ent, "esc")
	if (next_)
		_ast_type_chk(next_, "esc")
	_ast_set(("next_=" ent), next_)
}
function ast_esc_get_next_(ent) {
	_ast_type_chk(ent, "esc")
	return _ast_get(("next_=" ent))
}

# <\type-esc>
# <\types>
# <\structs-ast>
# <error>
function ast_errq(msg) {error_quit(sprintf("ast: %s", msg))}
# </error>

# <tree>
function ast_root_set(root) {_B_ast_root = root}
function ast_root() {return _B_ast_root}

function ast_start_create(nont) {
	return ast_start_make(nont, "", "", lex_get_line_no(), ast_lhs_lst_make())
}
function ast_start_push_lhs(start, lhs,    _lst) {
	_lst = ast_start_get_lhs_lst(start)
	if (!ast_lhs_lst_get_head(_lst)) {
		ast_lhs_lst_set_head(_lst, lhs)
		ast_lhs_lst_set_tail(_lst, lhs)
	} else {
		ast_lhs_set_next_(ast_lhs_lst_get_tail(_lst), lhs)
		ast_lhs_lst_set_tail(_lst, lhs)
	}
}
function ast_start_first_lhs(start) {
	return ast_lhs_lst_get_head(ast_start_get_lhs_lst(start))
}
function ast_start_last_lhs(start) {
	return ast_lhs_lst_get_tail(ast_start_get_lhs_lst(start))
}

function ast_lhs_create(name, line_num) {
	if (!line_num)
		line_num = lex_get_line_no()
	return ast_lhs_make(name, line_num, ast_rule_lst_make())
}
function ast_lhs_push_rule(lhs, rule,    _lst) {
	_lst = ast_lhs_get_rule_lst(lhs)
	if (!ast_rule_lst_get_head(_lst)) {
		ast_rule_lst_set_head(_lst, rule)
		ast_rule_lst_set_tail(_lst, rule)
	} else {
		ast_rule_set_next_(ast_rule_lst_get_tail(_lst), rule)
		ast_rule_lst_set_tail(_lst, rule)
	}
}
function ast_lhs_first_rule(lhs) {
	return ast_rule_lst_get_head(ast_lhs_get_rule_lst(lhs))
}
function ast_lhs_last_rule(lhs) {
	return ast_rule_lst_get_tail(ast_lhs_get_rule_lst(lhs))
}

function ast_rule_create() {
	return ast_rule_make(ast_esc_lst_make(), ast_sym_lst_make())
}
function ast_rule_push_sym(rule, sym,    _lst) {
	_lst = ast_rule_get_sym_lst(rule)
	if (!ast_sym_lst_get_head(_lst)) {
		ast_sym_lst_set_head(_lst, sym)
		ast_sym_lst_set_tail(_lst, sym)
	} else {
		ast_sym_set_next_(ast_sym_lst_get_tail(_lst), sym)
		ast_sym_lst_set_tail(_lst, sym)
	}
}
function ast_rule_first_sym(rule) {
	return ast_sym_lst_get_head(ast_rule_get_sym_lst(rule))
}
function ast_rule_last_sym(rule) {
	return ast_sym_lst_get_tail(ast_rule_get_sym_lst(rule))
}
function ast_rule_push_esc(rule, esc,    _lst) {
	_lst = ast_rule_get_esc_lst(rule)
	if (!ast_esc_lst_get_head(_lst)) {
		ast_esc_lst_set_head(_lst, esc)
		ast_esc_lst_set_tail(_lst, esc)
	} else {
		ast_esc_set_next_(ast_esc_lst_get_tail(_lst), esc)
		ast_esc_lst_set_tail(_lst, esc)
	}
}
function ast_rule_first_esc(rule) {
	return ast_esc_lst_get_head(ast_rule_get_esc_lst(rule))
}
function ast_rule_last_esc(rule) {
	return ast_esc_lst_get_tail(ast_rule_get_esc_lst(rule))
}

function ast_sym_create(type, name) {
	return ast_sym_make(type, name, "", ast_esc_lst_make())
}
function ast_sym_push_esc(sym, esc,    _lst) {
	_lst = ast_sym_get_esc_lst(sym)
	if (!ast_esc_lst_get_head(_lst)) {
		ast_esc_lst_set_head(_lst, esc)
		ast_esc_lst_set_tail(_lst, esc)
	} else {
		ast_esc_set_next_(ast_esc_lst_get_tail(_lst), esc)
		ast_esc_lst_set_tail(_lst, esc)
	}
}
function ast_sym_first_esc(sym) {
	return ast_esc_lst_get_head(ast_sym_get_esc_lst(sym))
}
function ast_sym_last_esc(sym) {
	return ast_esc_lst_get_tail(ast_sym_get_esc_lst(sym))
}

function ast_esc_create(name) {return ast_esc_make(name)}
# </tree>

# <modifiers>
function ast_mod_mark(name, mod,    _curr) {
	if (!index((_curr = _B_ast_mod_db[name]), mod)) {
		_B_ast_mod_db[name] = (_curr mod)
		if (PLUS() == mod)
			ast_mod_mark(name, STAR())
	}
}
function ast_mod_has(name, mod) {
	return ((name in _B_ast_mod_db) && index(_B_ast_mod_db[name], mod))
}

function _ast_mod_rename(name, mod) {
	if (QMARK() == mod)
		mod = "_opt"
	else if (STAR() == mod)
		mod = "_star"
	else if (PLUS() == mod)
		mod = "_plus"
	return (name mod)
}
function _ast_mod_discover(ent,    _type, _name, _mod, _next) {
	if (!ent)
		return

	_type = ast_type_of(ent)
	if (AST_START() == _type) {
		_name = ast_start_get_top_nont(ent)
		if (_mod = ast_start_get_mod(ent)) {
			ast_mod_mark(_name, _mod)
			_name = _ast_mod_rename(_name, _mod)
			ast_start_set_top_nont(ent, _name)
			ast_start_set_mod(ent, "")
		}
		_next = ast_start_first_lhs(ent)
	} else if (AST_LHS() == _type) {
		_ast_mod_discover(ast_lhs_first_rule(ent))
		_next = ast_lhs_get_next_(ent)
	} else if (AST_RULE() == _type) {
		_ast_mod_discover(ast_rule_first_sym(ent))
		_next = ast_rule_get_next_(ent)
	} else if (AST_SYM() == _type) {
		_name = ast_sym_get_name(ent)
		if (_mod = ast_sym_get_mod(ent)) {
			ast_mod_mark(_name, _mod)
			_name = _ast_mod_rename(_name, _mod)
			ast_sym_set_name(ent, _name)
			ast_sym_set_mod(ent, "")
		}
		_next = ast_sym_get_next_(ent)
	}

	_ast_mod_discover(_next)
}

# <rewrite>
function ZERO() {return "0"}
function NO_LINE() {return "-"}
function _ast_lhs_create_nl(name) {return ast_lhs_create(name, NO_LINE())}

function _ast_mod_defn_star(lhs,    _name, _mod_name, _rule, _ropt, _next) {
	# foo* becomes
	# foo_star : foo foo_star | 0

	_name = ast_lhs_get_name(lhs)
	_mod_name = _ast_mod_rename(_name, STAR())

	_ropt = ast_rule_create()
	ast_rule_push_sym(_ropt, ast_sym_create(ZERO(), ZERO()))

	_rule = ast_rule_create()
	ast_rule_push_sym(_rule, ast_sym_create(NONT(), _name))
	ast_rule_push_sym(_rule, ast_sym_create(NONT(), _mod_name))

	_next = _ast_lhs_create_nl(_mod_name)
	ast_lhs_push_rule(_next, _rule)
	ast_lhs_push_rule(_next, _ropt)

	ast_lhs_set_next_(_next, ast_lhs_get_next_(lhs))
	ast_lhs_set_next_(lhs, _next)
}
function _ast_mod_defn_plus(lhs,    _name, _mod_name, _next, _rule) {
	# foo+ becomes
	# foo_plus : foo foo_star

	_name = ast_lhs_get_name(lhs)

	_rule = ast_rule_create()
	ast_rule_push_sym(_rule, ast_sym_create(NONT(), _name))
	_mod_name = _ast_mod_rename(_name, STAR())
	ast_rule_push_sym(_rule, ast_sym_create(NONT(), _mod_name))

	_mod_name = _ast_mod_rename(_name, PLUS())
	_next = _ast_lhs_create_nl(_mod_name)
	ast_lhs_push_rule(_next, _rule)

	ast_lhs_set_next_(_next, ast_lhs_get_next_(lhs))
	ast_lhs_set_next_(lhs, _next)
}
function _ast_mod_defn_opt(lhs,    _name, _mod_name, _next, _rule, _ropt) {
	# foo? becomes
	# foo_opt : foo | 0

	_name = ast_lhs_get_name(lhs)
	_mod_name = _ast_mod_rename(_name, QMARK())

	_rule = ast_rule_create()
	ast_rule_push_sym(_rule, ast_sym_create(NONT(), _name))

	_ropt = ast_rule_create()
	ast_rule_push_sym(_ropt, ast_sym_create(ZERO(), ZERO()))

	_next = _ast_lhs_create_nl(_mod_name)
	ast_lhs_push_rule(_next, _rule)
	ast_lhs_push_rule(_next, _ropt)

	ast_lhs_set_next_(_next, ast_lhs_get_next_(lhs))
	ast_lhs_set_next_(lhs, _next)
}
function _ast_mod_defn(lhs,    _name) {
	_name = ast_lhs_get_name(lhs)
	if (ast_mod_has(_name, STAR()))
		_ast_mod_defn_star(lhs)
	if (ast_mod_has(_name, PLUS()))
		_ast_mod_defn_plus(lhs)
	if (ast_mod_has(_name, QMARK()))
		_ast_mod_defn_opt(lhs)
}
function _ast_mod_resolve(ent,    _type, _next) {
	if (!ent)
		return

	_type = ast_type_of(ent)
	if (AST_START() == _type) {
		_next = ast_start_first_lhs(ent)
	} else if (AST_LHS() == _type) {
		_ast_mod_defn(ent)
		_next = ast_lhs_get_next_(ent)
	}

	_ast_mod_resolve(_next)
}
function ast_mod_rewrite(    _root) {
	_root = ast_root()
	_ast_mod_discover(_root)
	_ast_mod_resolve(_root)
}
# </rewrite>
# </modifiers>

# <to-sym-tbl>
function _ast_tst_add_lhs(lhs) {st_lhs_add(lhs)}
function _ast_tst_add_sym_term(term) {
	st_name_term_add(term)
	st_rule_pos_add(term)
}
function _ast_tst_add_sym_nont(nont) {
	st_name_nont_add(nont)
	st_rule_pos_add(nont)
}

function _ast_tst_place_rule(arr_names, arr_types, len,    _i, _rs, _nm, _tp) {
	for (_i = 1; _i <= len; ++_i) {
		_nm = arr_names[_i]
		_tp = arr_types[_i]

		if (ESC() == _tp)
			_nm = ("\\" _nm)

		_rs = (_rs _nm)
		if (_i < len)
			_rs = (_rs " ")
	}

	st_lhs_rule_add(_rs)

	for (_i = 1; _i <= len; ++_i) {
		_nm = arr_names[_i]
		_tp = arr_types[_i]

		if (TERM() == _tp) {
			st_name_term_add(_nm)
			st_rule_pos_add(_nm)
		} else if (NONT() == _tp) {
			st_name_nont_add(_nm)
			st_rule_pos_add(_nm)
		} else if (ZERO() == _tp) {
			st_name_mark_can_null(st_lhs_last())
			st_name_mark_can_null(st_rule_name_last())
			st_rule_pos_add(ZERO())
		} else if (ESC() == _tp) {
			st_rule_pos_esc_add(_nm)
		}
	}

	for (_i = len; _i > 0; --_i) {
		_nm = arr_names[_i]
		_tp = arr_types[_i]

		if (ESC() != _tp) {
			if (NONT() == _tp && st_lhs_last() == _nm) {
				st_name_mark_tail_rec(st_lhs_last())
				st_name_mark_tail_rec(st_rule_name_last())
			}

			break
		}
	}
}

function _ast_tst_add_rule(ent,    _arr_nm, _arr_tp, _len, _n) {
	_n = ast_rule_first_esc(ent)
	while (_n) {
		++_len
		_arr_nm[_len] = ast_esc_get_name(_n)
		_arr_tp[_len] = ESC()
		_n = ast_esc_get_next_(_n)
	}

	_n = ast_rule_first_sym(ent)
	_len = _ast_tst_get_rule_syms(_n, _arr_nm, _arr_tp, _len)
	_ast_tst_place_rule(_arr_nm, _arr_tp, _len)
}
function _ast_tst_get_rule_syms(ent, arr_out_names, arr_out_types, len,    _n) {
	if (!ent)
		return len

	++len
	arr_out_names[len] = ast_sym_get_name(ent)
	arr_out_types[len] = ast_sym_get_type(ent)

	_n = ast_sym_first_esc(ent)
	while (_n) {
		++len
		arr_out_names[len] = ast_esc_get_name(_n)
		arr_out_types[len] = ESC()
		_n = ast_esc_get_next_(_n)
	}

	_n = ast_sym_get_next_(ent)
	return _ast_tst_get_rule_syms(_n, arr_out_names, arr_out_types, len)
}

function _ast_tst_add_start(ent,    _term, _nont, _rstr) {
	_nont = ast_start_get_top_nont(ent)
	_term = ast_start_get_eoi_term(ent)
	_rstr = sprintf("%s %s", _nont, _term)

	st_lhs_add(START_SYM(), ast_start_get_line_num(ent))
	st_lhs_rule_add(_rstr)
	st_name_nont_add(_nont)
	st_rule_pos_add(_nont)
	st_name_term_add(_term)
	st_rule_pos_add(_term)
	st_eoi_set(_term)
}
function ast_to_sym_tbl() {_ast_to_sym_tbl(ast_root())}
function _ast_to_sym_tbl(ent,    _type, _next) {
	if (!ent)
		return

	_type = ast_type_of(ent)
	if (AST_START() == _type) {
		_ast_tst_add_start(ent)
		_next = ast_start_first_lhs(ent)
	} else if (AST_LHS() == _type) {
		st_lhs_add(ast_lhs_get_name(ent), ast_lhs_get_line_num(ent))
		_ast_to_sym_tbl(ast_lhs_first_rule(ent))
		_next = ast_lhs_get_next_(ent)
	} else if (AST_RULE() == _type) {
		_ast_tst_add_rule(ent)
		_next = ast_rule_get_next_(ent)
	}

	_ast_to_sym_tbl(_next)
}
# </to-sym-tbl>

# <print>
# <dbg>
function ast_print_grammar() {_ast_print_grammar(ast_root())}
function _ast_print_grammar(ent,    _type, _next, _tmp) {
	if (!ent)
		return

	_type = ast_type_of(ent)
	if (AST_START() == _type) {
		printf("start : %s", ast_start_get_top_nont(ent))

		if (_tmp = ast_start_get_mod(ent))
			printf("%s", _tmp)
		printf(" ")
		print ast_start_get_eoi_term(ent)
		print ""

		_next = ast_start_first_lhs(ent)
	} else if (AST_LHS() == _type) {
		printf("%s : ", ast_lhs_get_name(ent))

		_ast_print_grammar(ast_lhs_first_rule(ent))
		print ""
		_next = ast_lhs_get_next_(ent)
	} else if (AST_RULE() == _type) {
		_ast_print_grammar(ast_rule_first_esc(ent))
		_ast_print_grammar(ast_rule_first_sym(ent))
		_next = ast_rule_get_next_(ent)
		if (_next && AST_RULE() == ast_type_of(_next))
			printf("\n\t| ")
		else
			print ""
	} else if (AST_SYM() == _type) {
		if (_tmp = ast_sym_get_name(ent))
			printf("%s", _tmp)
		if (_tmp = ast_sym_get_mod(ent))
			printf("%s", _tmp)

		printf(" ")
		_ast_print_grammar(ast_sym_first_esc(ent))

		_next = ast_sym_get_next_(ent)
	} else if (AST_ESC() == _type) {
		if (_tmp = ast_esc_get_name(ent))
			printf("\\%s ", _tmp)

		_next = ast_esc_get_next_(ent)
	}

	_ast_print_grammar(_next)
}

# <dbg>
function ast_dbg_print(ent,    _type, _next, _tmp) {
	if (!ent)
		return

	_type = ast_type_of(ent)
	if (AST_START() == _type) {
		printf("start (line %s) : %s", ast_start_get_line_num(ent), \
			ast_start_get_top_nont(ent))

		if (_tmp = ast_start_get_mod(ent))
			printf("%s", _tmp)
		printf(" ")
		print ast_start_get_eoi_term(ent)
		print ""

		_next = ast_start_first_lhs(ent)
	} else if (AST_LHS() == _type) {
		printf("%s (line %s) : ", ast_lhs_get_name(ent), \
			ast_lhs_get_line_num(ent))

		ast_dbg_print(ast_lhs_first_rule(ent))
		print ""
		_next = ast_lhs_get_next_(ent)
	} else if (AST_RULE() == _type) {
		ast_dbg_print(ast_rule_first_esc(ent))
		ast_dbg_print(ast_rule_first_sym(ent))
		_next = ast_rule_get_next_(ent)
		if (_next && AST_RULE() == ast_type_of(_next))
			printf("\n\t| ")
		else
			print ""
	} else if (AST_SYM() == _type) {
		if (_tmp = ast_sym_get_name(ent))
			printf("%s", _tmp)
		if (_tmp = ast_sym_get_mod(ent))
			printf("%s", _tmp)

		printf(" ")
		ast_dbg_print(ast_sym_first_esc(ent))

		_next = ast_sym_get_next_(ent)
	} else if (AST_ESC() == _type) {
		if (_tmp = ast_esc_get_name(ent))
			printf("\\%s ", _tmp)

		_next = ast_esc_get_next_(ent)
	}

	ast_dbg_print(_next)
}
# </dbg>
# </print>
# </ast>
# <sym-tbl>
# <private>
function _st_has(n) {return map_has(_B_st_data, n)}
function _st_get(n) {return map_get(_B_st_data, n)}
function _st_set(n, v) {_B_st_data[n] = v}
# </private>

# <print>
function st_print_rules(    _i, _ei, _j, _ej, _nm) {
	_ei = st_rule_count()
	for (_i = 1; _i <= _ei; ++_i) {
		printf("rule %d %s %s : ", _i, st_rule_name(_i), st_rule_lhs(_i))
		_ej = st_rule_pos_count(_i)
		for (_j = 1; _j <= _ej; ++_j)
			printf("%s ", st_rule_pos_name(_i, _j))
		print ""
	}
}
# </print>

# <name>
function st_name_count() {return _st_name_set_len(_ST_SNAME())}
function st_name(n)      {return _st_name_set_at(_ST_SNAME(), n)}
function st_name_type(name) {return _st_get(sprintf("name.type=%s", name))}

function st_name_term_count() {return _st_name_set_len(_ST_STERM())}
function st_name_term(n)      {return _st_name_set_at(_ST_STERM(), n)}
function st_name_nont_count() {return _st_name_set_len(_ST_SNONT())}
function st_name_nont(n)      {return _st_name_set_at(_ST_SNONT(), n)}
function st_name_lhs_count()  {return _st_name_set_len(_ST_SLHS())}
function st_name_lhs(n)       {return _st_name_set_at(_ST_SLHS(), n)}
function st_name_rule_count() {return _st_name_set_len(_ST_SRULE())}
function st_name_rule(n)      {return _st_name_set_at(_ST_SRULE(), n)}

function st_name_can_null(name) {
	return _st_has(sprintf("name.null.set=%s", name))
}
function st_name_is_tail_rec(name) {
	return _st_has(sprintf("name.trec.set=%s", name))
}
function st_name_is_term(name) {return _st_name_set_has(_ST_STERM(), name)}
function st_name_is_nont(name) {return _st_name_set_has(_ST_SNONT(), name)}
function st_name_is_lhs(name)  {return _st_name_set_has(_ST_SLHS(), name)}
function st_name_is_rule(name) {return _st_name_set_has(_ST_SRULE(), name)}
function st_name_is_zero(name) {return ("0" == name)}

function st_name_term_add(name) {_st_name_add(name, _ST_TTERM())}
function st_name_nont_add(name) {_st_name_add(name, _ST_TNONT())}
function st_name_lhs_add(name)  {_st_name_add(name, _ST_TLHS())}
function st_name_rule_add(name) {_st_name_add(name, _ST_TRULE())}

function st_name_mark_can_null(name) {
	_st_set(sprintf("name.null.set=%s", name))
}
function st_name_mark_tail_rec(name) {
	_st_set(sprintf("name.trec.set=%s", name))
}

# <private>
function _ST_TTERM() {return "t"}
function _ST_TNONT() {return "n"}
function _ST_TLHS()  {return "nl"}
function _ST_TRULE() {return "nr"}

function _ST_STERM() {return "term"}
function _ST_SNONT() {return "nont"}
function _ST_SLHS()  {return "lhs"}
function _ST_SRULE() {return "rule"}
function _ST_SNAME() {return "name"}

function _st_name_add(name, type,    _chg) {
	_chg = 0
	_chg = keep(_st_name_name_add(name), _chg)
	if (index(type, "t")) _chg = keep(_st_name_term_add(name), _chg)
	if (index(type, "n")) _chg = keep(_st_name_nont_add(name), _chg)
	if (index(type, "l")) _chg = keep(_st_name_lhs_add(name), _chg)
	if (index(type, "r")) _chg = keep(_st_name_rule_add(name), _chg)
	if (_chg) _st_set(sprintf("name.type=%s", name), type)
}

function _st_name_name_add(name) {return _st_name_set_add(_ST_SNAME(), name)}
function _st_name_term_add(name) {return _st_name_set_add(_ST_STERM(), name)}
function _st_name_nont_add(name) {return _st_name_set_add(_ST_SNONT(), name)}
function _st_name_lhs_add(name)  {return _st_name_set_add(_ST_SLHS(), name)}
function _st_name_rule_add(name) {return _st_name_set_add(_ST_SRULE(), name)}

function _st_name_set_len(set_name) {
	return _st_get(sprintf("name.%s.set.len", set_name))+0
}
function _st_name_set_at(set_name, pos) {
	return _st_get(sprintf("name.%s.set.str=%d", set_name, pos))
}
function _st_name_set_has(set_name, name) {
	return _st_has(sprintf("name.%s.set.num=%s", set_name, name))
}
function _st_name_set_add(set_name, name) {
	if (_st_name_set_has(set_name, name))
		return 0

	_n = sprintf("name.%s.set.len", set_name)
	_st_set(_n, (_c = _st_get(_n)+1))
	_n = sprintf("name.%s.set.str=%d", set_name, _c)
	_st_set(_n, name)
	_n = sprintf("name.%s.set.num=%s", set_name, name)
	_st_set(_n, _c)
	return 1
}
# </private>
# </name>

# <eoi>
function st_eoi_set(nm) {_st_set("eoi", nm)}
function st_eoi()       {return _st_get("eoi")}
# </eoi>

# <lsh>
function st_lhs_count() {return st_name_lhs_count()}
function st_lhs(n)      {return st_name_lhs(n)}
function st_lhs_is_tail_rec(lhs) {return st_name_is_tail_rec(lhs)}
function st_lhs_line_num(name)   {return _st_get(sprintf("lhs.lnum=%s", name))}
function st_lhs_rule_count(name) {return _st_get(sprintf("lhs.rules=%s", name))}
function st_lhs_rule_id(lhs, n) {
	return _st_get(sprintf("lhs.rule=%s.%d", lhs, n))
}

function st_lhs_add(name, lnum,    _n) {
	if (st_name_is_lhs(name))
		err_quit_fpos(sprintf("non-terminal '%s' redefined", name), lnum)
	st_name_lhs_add(name)
	_n = sprintf("lhs.lnum=%s", name)
	_st_set(_n, lnum)
}
function st_lhs_rule_add(rstr,    _c, _n, _lhs, _rname) {
	_lhs = st_lhs_last()
	_n = sprintf("lhs.rules=%s", _lhs)
	_st_set(_n, (_c = _st_get(_n)+1))
	_rname = sprintf("%s_%d", _lhs, _c)
	_st_rule_add(_lhs, _rname, rstr)
	_n = sprintf("lhs.rule=%s.%d", _lhs, _c)
	_st_set(_n, st_rule_count())
}
function st_lhs_last() {return st_lhs(st_lhs_count())}
# </lsh>

# <rule>
function st_rule_count() {return st_name_rule_count()}
function st_rule_name(n) {return st_name_rule(n)}
function st_rule_lhs(n) {return _st_get(sprintf("rule.lhs=%d", n))}
function st_rule_is_zero(n) {return st_name_is_zero(st_rule_pos_name(n, 1))}
function st_rule_str(n) {return _st_get(sprintf("rule.str=%d", n))}

function st_rule_pos_count(n) {return _st_get(sprintf("rule.pos.len=%d", n))}
function st_rule_pos_name(r, n) {
	return _st_get(sprintf("rule.pos.name=%d.%d", r, n))

}
function st_rule_pos_esc_count(r, n) {
	return _st_get(sprintf("rule.pos.esc.len=%d.%d", r, n))
}
function st_rule_pos_esc(r, p, n) {
	return _st_get(sprintf("rule.pos.esc=%d.%d.%d", r, p, n))
}

function st_rule_is_tail_rec(n) {return st_name_is_tail_rec(st_rule_name(n))}

function st_rule_pos_esc_add(esc,    _c, _n, _r, _p) {
	_r = st_rule_count()
	_p = _st_rule_pos_last()
	_n = sprintf("rule.pos.esc.len=%d.%d", _r, _p)
	_st_set(_n, (_c = _st_get(_n)+1))
	_n = sprintf("rule.pos.esc=%d.%d.%d", _r, _p, _c)
	_st_set(_n, esc)
}

function st_rule_pos_add(name,    _c, _n, _r) {
	_r = st_rule_count()
	_n = sprintf("rule.pos.len=%d", _r)
	_st_set(_n, (_c = _st_get(_n)+1))
	_n = sprintf("rule.pos.name=%d.%d", _r, _c)
	_st_set(_n, name)
}

function st_rule_name_last() {return st_rule_name(st_rule_count())}

# <private>
function _st_rule_add(lhs, name, rstr,    _c, _n) {
	st_name_rule_add(name)
	_c = st_rule_count()
	_n = sprintf("rule.lhs=%d", _c)
	_st_set(_n, lhs)
	_n = sprintf("rule.str=%d", _c)
	_st_set(_n, rstr)
	_n = sprintf("rule.pos.len=%d", _c)
	_st_set(_n, -1)
	st_rule_pos_add(name)
}
function _st_rule_pos_last() {return st_rule_pos_count(st_rule_count())}
# </private>
# </rule>

# <dbg>
function st_dbg_print_esc(rid, n,    _i, _end) {
	_end = st_rule_pos_esc_count(rid, n)
	for (_i = 1; _i <= _end; ++_i)
		printf("\\%s ", st_rule_pos_esc(rid, n, _i))
}
function st_dbg_print_rule(rid,    _i, _end, _str) {
	printf("%s : ", st_rule_lhs(rid))
	_end = st_rule_pos_count(rid)
	for (_i = 0; _i <= _end; ++_i) {
		_str = st_rule_pos_name(rid, _i)

		if (0 == _i) {
			printf("(%s) ", _str)

			if (st_name_is_tail_rec(_str))
				printf("(tr) ")

			if (st_name_can_null(_str))
				printf("(0) ")
		} else {
			printf("%s ", _str)
		}

		st_dbg_print_esc(rid, _i)
	}
	print ""
}
function st_dbg_print_lhs(name,    _i, _end, _lhs) {
	_lhs = sprintf("%s (line %s)", name, st_lhs_line_num(name))

	if (st_name_can_null(name))
		_lhs = (_lhs " (0)")

	if (st_name_is_tail_rec(name))
		_lhs = (_lhs " (tr)")

	print sprintf("%s", _lhs)

	_end = st_lhs_rule_count(name)
	for (_i = 1; _i <= _end; ++_i)
		st_dbg_print_rule(st_lhs_rule_id(name, _i))
}
function st_dbg_print(    _i, _end) {
	_end = st_lhs_count()
	for (_i = 1; _i <= _end; ++_i) {
		st_dbg_print_lhs(st_lhs(_i))
		print ""
	}
}
function st_dbg_dump(    _n) {
	for (_n in _B_st_data)
		print sprintf("st[\"%s\"] = %s", _n, _B_st_data[_n])
}
# </dbg>
# </sym-tbl>
# <misc>
function keep(a, b) {return a || b}
function map_has(map, n) {return (n in map)}
function map_get(map, n) {return map_has(map, n) ? map[n] : ""}
# </misc>
# </parser>
