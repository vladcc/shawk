# <user_messages>
function use_str() {
	return sprintf("Use: awk -f %s <input-file>", SCRIPT_NAME())
}

function print_use_try() {
	pstderr(use_str())
	pstderr(sprintf("Try '%s -vHelp=1' for more info", SCRIPT_NAME()))
	exit_failure()
}

function print_version() {
	print sprintf("%s %s", SCRIPT_NAME(), SCRIPT_VERSION())
	exit_success()
}

function STRICT() {return "-vStrict=1"}
function EXAMPLE() {return "-vExample=1"}
function print_help() {
print sprintf("--- %s %s ---", SCRIPT_NAME(), SCRIPT_VERSION())
print "LL(1) recursive descent parser generator"
print ""
print use_str()
print ""
print "Options:"
print sprintf("%s  - any reference to a non-defined CFG rule is an error", STRICT())
print sprintf("%s - print infix calculator example", EXAMPLE())
print "-vHelp=1    - print this screen"
print "-vVersion=1 - print version"
print ""
print sprintf("%s itself is a line oriented state machine parser which parses",
	SCRIPT_NAME())
print "by the rules described below. Note: these rules are different in meaning"
print "than the rules in the context of context free grammars. Unlike CFG rules,"
print "these only describe the sequence in which they must themselves appear in"
print "the input file."
print ""
print "Rules:"
print "'->' means 'must be followed by'"
print "'|'  means 'or'"
print "Each line of the input file must begin with a rule."
print "The rules must appear in the below order of definition."
print "Empty lines and lines which start with '#' are ignored."
print ""
print "rule -> defn"
print "defn -> defn | goal | fail | end"
print "goal -> defn | fail | end"
print "fail -> end"
print "end -> rule"
print ""
print "Here's how the above is used to describe a context free grammar:"
print "Note: the below is only a demonstration. The grammar doesn't really make sense."
print sprintf("For a grammar which does, please run with the %s flag.", EXAMPLE())
print ""
print "expression := term expr_rest"
print "term := NUMBER"
print "expr_rest := plus_minus_term expr_rest"
print "plus_minus_term := PLUS term | MINUS term | eps"
print ""
print sprintf("in %s syntax becomes:", SCRIPT_NAME())
print ""
print "rule expression"
print "defn term expr_rest"
print "end"
print "rule term"
print "defn NUMBER"
print "end"
print "rule expr_rest"
print "defn plus_minus_term expr_rest"
print "end"
print "rule plus_minus_term?"
print "defn PLUS term"
print "defn MINUS term"
print "end"
print ""
print "Note that an epsilon transition is marked by a '?' after the rule name."
print "This makes it easier for the line parser to parse. A goal can be"
print "associated with each definition. A goal is an action, usually a function"
print "call, which is executed after a successful match of the definition:"
print ""
print "rule plus_minus_term?"
print "defn PLUS term"
print "goal add()"
print "defn MINUS term"
print "goal sub()"
print "end"
print ""
print "Similarly, a single fail action can be associated with a rule:"
print ""
print "rule plus_minus_term?"
print "defn PLUS term"
print "goal add()"
print "defn MINUS term"
print "goal sub()"
print "fail exit(EXIT_FAILURE)"
print "end"
print ""
print "This fail action gets executed if none of the defn were matched."
print sprintf("%s detects left recursion and is language agnostic. It compiles", 
	SCRIPT_NAME())
print "it's input to an intermediate representation, which can then be piped"
print "into the optimizer - rdpg-opt.awk, which, depending on the optimization"
print "level, can replace naive code like 'if (foo()) {return true} else "
print "{return false}' with something more succinct like 'return foo()'. It can"
print "also get rid of redundant elses, unreachable code (defined as any code"
print "between the first return statement in the current block and the end of the"
print "same block), optimize tail recursion, and inline functions. If optimization"
print "is used, the output of the optimizer is again ir code. Ultimately, the ir"
print "is fed into some back end, like rdpg-to-c.awk, which translates it to the"
print "target language. This translation is more or less trivial, as is writing"
print "a custom back end for a desired target language. Note that in order to have"
print "a language agnostic grammar, the goal and fail actions should be written in"
print "ir as well. E.g."
print ""
print "rule plus_minus_term?"
print "defn PLUS term"
print "goal call add"
print "defn MINUS term"
print "goal call sub"
print "fail call exit EXIT_FAILURE"
print "end"
print ""
print "Similarly:"
print ""
print "rule statement"
print "defn expression SEMI"
print "fail return sync_on(SEMI)"
print "end"
print ""
print "Becomes:"
print ""
print "rule statement"
print "defn expression SEMI"
print "fail return call sync_on SEMI"
print "end"
print ""
print "Note that in the rdpg language, any lower case symbol is a non-terminal,"
print "which gets translated to a function call. Any upper case symbol is a token,"
print "which gets translated to a token matching functions. " SCRIPT_NAME() " assumes the"
print "existence of three token related functions - one for consuming a token, one for"
print "matching the current token to an expected token, and one for reporting mismatch"
print "errors. A mismatch error is generally supposed to have the form of 'expected X,"
print "got Y instead'. The assumed names of the three functions can be found in the"
print "IR_TOK_* constants."
print ""
print "It's worth mentioning that if a rule is nullable, i.e. if it ends with a"
print "'?', this in practice means that:"
print "a) token mismatches do not generate errors inside that rule"
print "b) the caller rule always returns true whether or not the nullable rule failed,"
print "given that the nullable rule is the only call, i.e. it's not a part of an if"
print "chain of calls. This is because making a rule nullable makes it optional, i.e."
print "it's ok not to match."
exit_success()
}

function print_example() {
print "# start symbol"
print "rule parse"
print "defn statements"
print "end"
print ""
print "rule statements"
print "defn statement eoi"
print "defn statement statements"
print "end"
print ""
print "rule eoi?"
print "defn EOI"
print "end"
print ""
print "# if parsing an expression failed, eat tokens until you see ';'"
print "rule statement"
print "defn expression_sync"
print "fail return call sync SEMI"
print "end"
print ""
print "# intermediate rule, so expression can fail at a single point"
print "rule expression_sync"
print "defn expression SEMI"
print "end"
print ""
print "rule expression"
print "defn term expr_rest"
print "end"
print ""
print "rule expr_rest"
print "defn plus_minus_term expr_rest"
print "end"
print ""
print "# it's ok to not have addition or subtraction in an expression"
print "rule plus_minus_term?"
print "defn PLUS term"
print "goal call add"
print "defn MINUS term"
print "goal call subt"
print "end"
print ""
print "rule term"
print "defn factor term_tail"
print "end"
print ""
print "rule term_tail"
print "defn div_mul_factor term_tail"
print "end"
print ""
print "# it's ok to not have multiplication or division in an expression"
print "rule div_mul_factor?"
print "defn MUL factor"
print "goal call mult"
print "defn DIV factor"
print "goal call divd"
print "end"
print ""
print "rule factor"
print "defn base expon"
print "end"
print ""
print "# right associative"
print "rule expon?"
print "defn EXP factor"
print "goal call power"
print "end"
print ""
print "rule base"
print "defn single NUMBER"
print "goal call push_val"
print "defn NUMBER"
print "goal call push_val"
print "defn LPAR expression RPAR"
print "end"
print ""
print "# optional negation"
print "rule single?"
print "defn MINUS"
print "goal call neg"
print "defn PLUS"
print "end"
	exit_success()
}
# </user_messages>
