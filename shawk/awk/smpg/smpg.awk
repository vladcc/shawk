#!/usr/bin/awk -f

# generated by smpg.awk 2.0

# <description>
function DESCRIPT_INCLUDES() {
return \
"included files:\n"\
"_smpg_doc.awk\n"\
"_smpg_generate.awk\n"\
"awklib_fsm.awk\n"\
"awklib_array.awk\n"\
"awklib_vect.awk\n"\
"awklib_prep.awk\n"\
"awklib_tabs.awk\n"\
"awklib_prog.awk\n"\
"awklib_read.awk\n"\
}
function DESCRIPT_FSM() {
return \
"fsm rules:\n"\
"BEGIN -> INCLUDE\n"\
"INCLUDE -> FSM\n"\
"FSM -> HANDLER\n"\
"HANDLER -> HANDLER | TEMPLATE\n"\
"TEMPLATE -> TEMPLATE | OTHER\n"\
"OTHER -> GENERATE\n"\
"GENERATE -> BEGIN\n"\
"\n"\
"'->' is read as 'must be followed by'\n"\
"'|' is read as 'or'"
}
function DESCRIPT() {
	return (DESCRIPT_INCLUDES() "\n" DESCRIPT_FSM())
}
# </description>

# <other>
# smpg.awk
# Vladimir Dinev
# vld.dinev@gmail.com
# 2022-11-27

# <awk_loop>
BEGIN {enter()}
END {leave()}
/^;|^[[:space:]]*$/ {next}
/^@/ {transition(remove_ats($1)); next}
{equit("line not source or a comment")}
# </awk_loop>

# <script_main>
function SCRIPT_NAME() {return "smpg.awk"}
function SCRIPT_VERSION() {return "2.0"}

function main() {
	# called in the 'generate' state
	generate_all()
	out_print()
}
# </script_main>

# <misc>
function enter() {
	set_program_name(SCRIPT_NAME())
	
	if (Help || Version || Doc || Template || ExampleInput || ExampleData) {
		if (Help)
			print_help()
		else if (Version)
			print_version()
		else if (Doc)
			print_doc()
		else if (Template)
			print_template_code()
		else if (ExampleInput)
			print_example_input()
		else if (ExampleData)
			print_example_data()
		
		skip_end_set()
		exit_success()
	}
	
	if (ARGC != 2) {
		pstderr(get_use_str())
		pstderr(sprintf("Try: %s -vHelp=1", get_program_name()))
		
		skip_end_set()
		exit_failure()
	}
}
function leave(    _st) {
	if (!did_error_happen() && !should_skip_end()) {
		if ((_st = get_state()) != STM_GENERATE())
			err_expect(STM_GENERATE(), _st, "end-of-file")
	}
}
function get_state() {return stm_get_state(B_the_fsm)}
function transition(st) {stm_next(B_the_fsm, st)}
function remove_ats(str) {
	sub("^@", "", str)
	return str
}
function str_cat(a, b, sep) {
	return (a ? (a (sep ? sep : SUBSEP) b) : b)
}
function equit(msg, line_no) {
	if (!line_no)
		line_no = FNR
	error_quit(sprintf("file '%s' line %s: %s", FILENAME, line_no, msg))
}
function err_expect(expect, got, line_no) {
	equit(sprintf("expected '%s', got '%s' instead", expect, got), line_no)
}
function init() {
	FSM_init()
	INCLUDE_init()
	HANDLER_init()
	TEMPLATE_init()
	OTHER_init()
}
function BLOCK_END() {return "^@END"}
function BLOCK_COMMENT() {return "^[[:space:]]*;"}
function get_src(    _arr, _len) {
	_len = read_lines(_arr, BLOCK_END(), BLOCK_COMMENT())
	return arr_to_str(_arr, _len, "\n")
}
function get_block(arr_out,    _len) {
	_len = read_lines(arr_out, BLOCK_END())
	arr_gsub(arr_out, _len, "^[[:space:]]+|[[:space:]]+$", "")
	arr_sub(arr_out, _len, "^[[:space:]]*;.*$", "")
	return _len
}
function out_print() {
	arr_print(B_vect_output, vect_len(B_vect_output), "\n")
}
function out_append_str(str) {
	vect_push(B_vect_output, str)
}
function out_append_arr(arr, len) {
	vect_push_arr(B_vect_output, arr, len)
}
# </misc>
# </other>

# <templated>
# 'FSM'
function FSM_init() {
	vect_init(B_vect_FSM)
	vect_init(B_vect_FSM_line_no)
}
function FSM_save_line(line, line_no) {
	vect_push(B_vect_FSM, line)
	vect_push(B_vect_FSM_line_no, line_no)
}
function FSM_save_name(str) {B_FSM_name = str}
function FSM_get_FSM_src(arr_out) {
	return arr_copy(arr_out, B_vect_FSM, vect_len(B_vect_FSM))
}
function FSM_get_line_no(n) {return B_vect_FSM_line_no[n]}
function FSM_get_name() {return B_FSM_name}
function FSM_syntax_error() {
	equit(sprintf("syntax should be '@%s <fsm-name>'",
				STM_FSM()))
}

# 'INCLUDE'
function INCLUDE_init() {
	vect_init(B_vect_INCLUDE)
	vect_init(B_vect_INCLUDE_line_no)
}
function INCLUDE_save_line(line, line_no) {
	vect_push(B_vect_INCLUDE, line)
	vect_push(B_vect_INCLUDE_line_no, line_no)
}
function INCLUDE_get_num() {return vect_len(B_vect_INCLUDE)}
function INCLUDE_get_line_no(n) {return B_vect_INCLUDE_line_no[n]}
function INCLUDE_get_fname(n) {return B_vect_INCLUDE[n]}
function INCLUDE_get_file_names(arr_out) {
	return arr_copy(arr_out, B_vect_INCLUDE, vect_len(B_vect_INCLUDE))
}

# 'HANDLER'
function HANDLER_init() {
	B_map_HANDLER[""]
	delete B_map_HANDLER
}
function HANDLER_map_rx_args(rx, arg_str,    _arr, _len, _args) {
	# str is assumed to be '@HANDLE <regex> [args]'
	_len = split(arg_str, _arr)
	_arr[1] = _arr[2] = " "
	_args = arr_to_str(_arr, _len, " ")
	sub("^[[:space:]]+", "", _args)
	B_map_HANDLER[rx, "args"] = _args
}
function HANDLER_save_rx(rx) {
	B_HANDLER_rx_list = str_cat(B_HANDLER_rx_list, rx)
}
function HANDLER_map_rx_src(rx, str) {B_map_HANDLER[rx, "src"] = str}
function HANDLER_get_rx_src(rx) {return B_map_HANDLER[rx, "src"]}
function HANDLER_get_rx_args(rx) {return B_map_HANDLER[rx, "args"]}
function HANDLER_get_rx_all(arr_out) {
	return split(B_HANDLER_rx_list, arr_out, SUBSEP)
}
function HANDLER_syntax_error() {
	equit(sprintf("syntax should be '@%s <regex> [args]'",
				STM_HANDLER()))
}

# 'TEMPLATE'
function TEMPLATE_init() {
	B_map_TEMPLATE[""]
	delete B_map_TEMPLATE
}
function TEMPLATE_save_rx(rx) {
	B_TEMPLATE_rx_list = str_cat(B_TEMPLATE_rx_list, rx)
}
function TEMPLATE_map_rx_src(rx, str) {B_map_TEMPLATE[rx, "src"] = str}
function TEMPLATE_get_rx_src(rx) {return B_map_TEMPLATE[rx, "src"]}
function TEMPLATE_get_rx_all(arr_out) {
	return split(B_TEMPLATE_rx_list, arr_out, SUBSEP)
}
function TEMPLATE_syntax_error() {
	equit(sprintf("syntax should be '@%s <regex>'", STM_TEMPLATE()))
}

# 'OTHER'
function OTHER_init() {B_OTHER_src = ""}
function OTHER_save_src(str) {B_OTHER_src = str}
function OTHER_get_src() {return B_OTHER_src}
# </templated>

# <stm>
# <handlers>
function stm_on_BEGIN() {
	init()
}
function stm_on_INCLUDE(    _arr, _len, _fnr, _i, _line) {
	_fnr = FNR
	_len = get_block(_arr)
	for (_i = 1; _i <= _len; ++_i) {
		_line = _arr[_i]
		if (_line)
			INCLUDE_save_line(_arr[_i], _fnr+_i)
	}
}
function stm_on_FSM(    _arr, _len, _fnr, _i, _line) {
	if (NF > 1) {
		FSM_save_name($2)
		_fnr = FNR
		_len = get_block(_arr)
		
		if (!_len)
			equit("'FSM' block empty")
		
		for (_i = 1; _i <= _len; ++_i) {
			_line = _arr[_i]
			if (_line)
				FSM_save_line(_arr[_i], _fnr+_i)
		}
	} else {
		FSM_syntax_error()
	}
}
function stm_on_HANDLER() {
	if (NF > 1) {
		HANDLER_save_rx($2)
		HANDLER_map_rx_args($2, $0)
		HANDLER_map_rx_src($2, get_src())
	} else {
		HANDLER_syntax_error()
	}
}
function stm_on_TEMPLATE() {
	if (NF > 1) {
		TEMPLATE_save_rx($2)
		TEMPLATE_map_rx_src($2, get_src())
	} else {
		TEMPLATE_syntax_error()
	}
}
function stm_on_OTHER() {
	OTHER_save_src(get_src())
}
function stm_on_GENERATE() {
	main()
}
function stm_on_error(curr_st, expected, got) {
	err_expect(expected, got)
}
# </handlers>

# <constants>
function STM_BEGIN() {return "BEGIN"}
function STM_INCLUDE() {return "INCLUDE"}
function STM_FSM() {return "FSM"}
function STM_HANDLER() {return "HANDLER"}
function STM_TEMPLATE() {return "TEMPLATE"}
function STM_OTHER() {return "OTHER"}
function STM_GENERATE() {return "GENERATE"}
function _STM_STATE() {return "state"}
# </constants>

# <functions>
function stm_get_state(stm) {return stm[_STM_STATE()]}
function _stm_set_state(stm, next_st) {stm[_STM_STATE()] = next_st}
function stm_next(stm, next_st,    _st) {

	_st = stm_get_state(stm)
	if ("" == _st) {
		if (STM_BEGIN() == next_st)
		{stm_on_BEGIN(); _stm_set_state(stm, next_st)}
		else
		{stm_on_error(_st, STM_BEGIN(), next_st)}
	}
	else if (STM_BEGIN() == _st) {
		if (STM_INCLUDE() == next_st)
		{stm_on_INCLUDE(); _stm_set_state(stm, next_st)}
		else
		{stm_on_error(_st, STM_INCLUDE(), next_st)}
	}
	else if (STM_INCLUDE() == _st) {
		if (STM_FSM() == next_st)
		{stm_on_FSM(); _stm_set_state(stm, next_st)}
		else
		{stm_on_error(_st, STM_FSM(), next_st)}
	}
	else if (STM_FSM() == _st) {
		if (STM_HANDLER() == next_st)
		{stm_on_HANDLER(); _stm_set_state(stm, next_st)}
		else
		{stm_on_error(_st, STM_HANDLER(), next_st)}
	}
	else if (STM_HANDLER() == _st) {
		if (STM_HANDLER() == next_st)
		{stm_on_HANDLER(); _stm_set_state(stm, next_st)}
		else if (STM_TEMPLATE() == next_st)
		{stm_on_TEMPLATE(); _stm_set_state(stm, next_st)}
		else
		{stm_on_error(_st, STM_HANDLER()"|"STM_TEMPLATE(), next_st)}
	}
	else if (STM_TEMPLATE() == _st) {
		if (STM_TEMPLATE() == next_st)
		{stm_on_TEMPLATE(); _stm_set_state(stm, next_st)}
		else if (STM_OTHER() == next_st)
		{stm_on_OTHER(); _stm_set_state(stm, next_st)}
		else
		{stm_on_error(_st, STM_TEMPLATE()"|"STM_OTHER(), next_st)}
	}
	else if (STM_OTHER() == _st) {
		if (STM_GENERATE() == next_st)
		{stm_on_GENERATE(); _stm_set_state(stm, next_st)}
		else
		{stm_on_error(_st, STM_GENERATE(), next_st)}
	}
	else if (STM_GENERATE() == _st) {
		if (STM_BEGIN() == next_st)
		{stm_on_BEGIN(); _stm_set_state(stm, next_st)}
		else
		{stm_on_error(_st, STM_BEGIN(), next_st)}
	}
}
# </functions>
# </stm>

# <includes>
# ./src/_smpg_doc.awk
# <smpg_messages>
function print_help() {
print SCRIPT_NAME() " -- a finite state machine parser generator"
print get_use_str()
print_nl()
print "All options are supplied in the typical '-v' awk fashion."
print_nl()
print "Options:"
print "-v Doc=1"
print "Print a description of the fsm parser idea and documentation for " SCRIPT_NAME()
print "If you unsure where to start, start here."
print_nl()
print "-v Template=1"
print "Print only the boilerplate code from the Doc option."
print_nl()
print "-v ExampleInput=1"
print "Print an example parser description."
print_nl()
print "-v ExampleData=1"
print "Print example data for the parser which can be generated from ExampleInput."
print_nl()
print "-v Help=1"
print "Print this screen."
print_nl()
print "-v Version=1"
print "Print version info."
print_nl()
print "To run the example:"
print "# get the parser description"
print "awk -f " SCRIPT_NAME() " -v ExampleInput=1 > example.smpg"
print_nl()
print "# generate the parser from the description"
print "awk -f " SCRIPT_NAME() " example.smpg > example.smpg.awk"
print_nl()
print "# get example data for the generated parser"
print "awk -f " SCRIPT_NAME() " -v ExampleData=1 > example.data.txt"
print_nl()
print "# give the data to the parser to generate a runnable test program"
print "awk -f example.smpg.awk example.data.txt > example.test.awk"
print_nl()
print "# finally, run the test program"
print "awk -f example.test.awk"
print_nl()
print "# clean up"
print "rm example.smpg example.smpg.awk example.data.txt example.test.awk"
}

function print_version() {
	print sprintf("%s %s", SCRIPT_NAME(), SCRIPT_VERSION())
}

function get_use_str() {
	return sprintf("Use: %s [options] <input-file>", SCRIPT_NAME())
}

function print_doc() {
print "1. Idea:"
print "A finite state machine parser recognizes a declarative language and is able"
print "to call user defined callbacks when each rule of that language is encountered."
print "When this is combined with awk's abilities for text processing, it becomes"
print "trivial to ensure correctness of input. The parser is line oriented and the"
print "first field of each line is the next state machine state. E.g. if the fsm was"
print "defined as:"
print_nl()
print "foo -> bar"
print "bar -> foo"
print_nl()
print "i.e. a 'foo' has to be followed by a 'bar', and a 'bar' has to be followed"
print "by a 'foo', then the parser will recognize files which look like:"
print_nl()
print "foo <something>"
print "bar <something>"
print "foo <something>"
print "bar <something>"
print "..."
print_nl()
print "That is, the first line must begin with 'foo', the one after that with 'bar',"
print "the one after that with 'foo' again and so on. Anything else than this"
print "constitutes an error and parsing stops. Each time 'foo' is read, a on_foo()"
print "function is called. This function is user defined and inside it is very"
print "easy to check if you have the <something>, what that <something> actually is,"
print "save it for later processing, etc. Respectively, a on_bar() function is called"
print "when a 'bar' is read. It is also very easy to make the parser read whole blocks"
print "instead of single lines by calling 'getline' from inside the handlers until"
print "some delimiter is read, e.g. 'end':"
print_nl()
print "foo"
print "<something>"
print "<something>"
print "..."
print "end"
print "bar"
print "<something>"
print "<something>"
print "..."
print "end"
print_nl()
print "2. " SCRIPT_NAME()
print SCRIPT_NAME() " is a fsm parser as described above which uses its input to"
print "generate another fsm parser. I.e. " SCRIPT_NAME() " is a fsm parser which"
print "takes a description of an fsm parser as input and outputs the fsm parser"
print "defined by that description. In practice, it's a lot simpler than it sounds."
print SCRIPT_NAME() " has the ability to include text, external files, and generate"
print "source code by regex text substitution. This gives it the ability to also"
print "generate itself. The description of " SCRIPT_NAME() " is:"
print_nl()
print DESCRIPT()
print_nl()
print "The included files are libraries and other functionality. The fsm rules"
print "are prepended by a '@', so they are distinguishable from their data. Lines"
print "which begin with a ';' are comments. Comments are only single line and take"
print "the whole line. The 'begin' and 'generate' state must appear alone on a line."
print "All other states are block oriented and delimited by '@END'. The full syntax"
print "is described below:"
print_nl()
print_template_code()
print_nl()
}

function print_template_code() {
print "; any line which begins with a ';' is a comment"
print "; the '@BEGIN' states tells the parser to initialize its data structures"
print_begin()
print_nl()
print_include()
print "; this block must exist even if empty"
print "; any file names which appear here will be appended verbatim to"
print "; the final script"
print "; this is one way to get libraries and other code in your parser"
print_end()
print_nl()
print_fsm("<fsm-name>")
print "; the syntax for the '@FSM' state is '@FSM <fsm-name>'"
print "; the <fsm-name> is prepended to all generated fsm functions"
print "; the rest of the text in this block is the fsm specification for the"
print "; parser which is to be generated"
print "; each fsm state gets its own handler function with the name:"
print "; '<fsm-name>_on_<state-name>()'"
print "; an implicit error handler with the name and arguments:"
print "; '<fsm-name>_on_error(curr_st, expected, got)' is also generated"
print "; for details on the fsm description syntax see examples, or awklib_fsm.awk"
print_end()
print_nl()
print_handler("<regex> [args]")
print "; <regex> is matched against the state names specified in the '@FSM' state"
print "; the non-comment text in this block then appears in the body of the handlers"
print "; for the state names which matched"
print "; any appearance of '{&}' in this text is replaced by the state name which"
print "; matched once for each match"
print "; [args], if given, are pasted verbatim in each handler's argument list"
print "; e.g., given:"
print "; '@HANDLER a|b _foo, _bar"
print "; \t{&}_save($0)"
print "; @END"
print "; function m_on_a(    _foo, _bar) {"
print "; \ta_save($0)"
print "; }"
print "; function m_on_b(    _foo, _bar) {"
print "; \tb_save($0)"
print "; }"
print "; is generated, assuming 'm' is the name given in '@FSM' and 'a' and 'b' are"
print "; state names which appear in the specification for 'm'"
print "; an arbitrary number of '@HANDLER' blocks can appear after each other,"
print "; however, once a state name is matched, it is not consider in subsequent"
print "; '@HANDLER' blocks"
print_end()
print_nl()
print_template("<regex>")
print "; the '@TEMPLATE' block works much like the '@HANDLER' block, except that"
print "; the '@TEMPLATE' block is used to generate functions, rather than source"
print "; for a specific function, e.g."
print "; @TEMPLATE a|b"
print "; \tfunction {&}_save(str) {_{&}_arr[++_{&}_arr_len] = str}"
print "; @END"
print "; will generate"
print "; function a_save(str) {_a_arr[++_a_arr_len] = str}"
print "; function b_save(str) {_b_arr[++_b_arr_len] = str}"
print "; again, assuming 'a' and 'b' are states of 'm' as above"
print "; like '@HANDLER', an arbitrary number of '@TEMPLATE' blocks can appear after"
print "; each other and once a state has matched it is not considered in any further"
print "; matching"
print_end()
print_nl()
print_other()
print "; any non-comment text which appears in this block is pasted verbatim in"
print "; the final script"
print_end()
print_nl()
print "; source generation begins when the '@GENERATE' state is reached"
print "; since the parser is a fsm, '@GENERATE' is reached only if all input"
print "; is correct"
print_generate()
}

function print_nl() {print ""}
function print_begin() {print "@BEGIN"}
function print_generate() {print "@GENERATE"}
function print_include() {print "@INCLUDE"}
function print_fsm(str) {print ("@FSM " str)}
function print_handler(str) {print ("@HANDLER " str)}
function print_template(str) {print ("@TEMPLATE " str)}
function print_other() {print "@OTHER"}
function print_end() {print "@END"}

function print_example_input() {

print "; this is example " SCRIPT_NAME() " input"
print "; it generates an awk finite state machine parser which generates an awk"
print "; test program for a few trivial math functions along with these functions"
print "; the generated state machine parser will accept files with the format:"
print ";"
print "; begin"
print "; func_name <func>"
print "; input <input>"
print "; output <output>"
print "; generate"
print ";"
print "; each 'func_name' can have one or more inputs and outputs, however, each"
print "; input must have an output after a 'generate', another 'begin' can follow"
print_nl()

print_begin()
print_nl()
print_include()
tabs_inc()
tabs_print("; this block must exist even if empty any file whose name appears here")
tabs_print("; will be appended to the final script verbatim")
tabs_dec()
print_end()
print_nl()

print "; the syntax for the fsm block is '@FSM <fsm-name>'"
print "; <fsm-name> prefixes the generated fsm functions"
print_fsm("stm")
tabs_inc()
tabs_print("begin -> func_name")
tabs_print("func_name -> input")
tabs_print("input -> output")
tabs_print("output -> input | generate")
tabs_print("generate -> begin")
tabs_dec()
print_end()
print_nl()

print "; the syntax for the handler block is '@HANDLER <name> [args]'"
print "; <name> is a regular expression which gets matched against all"
print "; state machine states in order"
print "; if [args] appear, they are pasted literally in the"
print "; handler's argument list"
print_handler("begin")
tabs_inc()
tabs_print("; any code here will appear in the stm_on_begin() function")
tabs_print("init()")
tabs_dec()
print_end()
print_nl()

print "; the '{&}' will be replaced by each handler's name"
print_handler("func_name|input|output")
tabs_inc()
tabs_print("; this is going to generate the same type of code for the three handlers")
tabs_print("; specified by the regex")
tabs_print("check_for_data()")
tabs_print("{&}_save($2)")
tabs_dec()
print_end()
print_nl()

print_handler("generate")
tabs_inc()
tabs_print("{&}()")
tabs_dec()
print_end()
print_nl()

print_handler("error")
tabs_inc()
tabs_print("; the error handler has these implicit arguments as per awklib_fsm")
tabs_print("error(\"line \" FNR \": expected \" expected \", got \" got)")
tabs_dec()
print_end()
print_nl()

print "; the template block works much like the handler blocks, except that a"
print "; template blocks generates general awk source code, while the handler"
print "; block generates the source for a specific handler function"
print "; the syntax for a template block is '@TEMPLATE <regex>'"
print_template("func_name|input|output")
print "function {&}_save(str) {_{&}_data[++_{&}_num] = str}"
print "function {&}_count() {return _{&}_num}"
print "function {&}_get(n) {return _{&}_data[n]}"
print "function {&}_clear() {delete _{&}_data; _{&}_num = 0}"
print_end()
print_nl()

print "; everything in the '@OTHER' block gets pasted as is in the final script"
print "; except any ';' line comments"
print "; here's where all the plumbing can get defined"
print_other()
print "function error(msg) {print \"error: \" msg; exit(1)}"
print "function check_for_data() {"
tabs_inc()
tabs_print("if (NF < 2)")
tabs_inc()
tabs_print("error(sprintf(\"line %d: data expected\", FNR))")
tabs_dec()
tabs_dec()
tabs_print("}")
print "function init() {"
tabs_inc()
tabs_print("func_name_clear()")
tabs_print("input_clear()")
tabs_print("output_clear()")
tabs_dec()
print "}"

print "BEGIN { "
print "\tprint \"function error(msg) {print \\\"error: \\\" msg; exit(1)}\""
print "\tprint \"function abs(n) {return (n < 0) ? -n : n}\""
print "\tprint \"function square(n) {return n*n}\""
print "\tprint \"BEGIN {\""
print "}"

print "function generate(    _func_name, _i, _end, _str) {"
tabs_inc()
tabs_print("_func_name = func_name_get(1)")
tabs_print("_end = input_count()")
tabs_print("for (_i = 1; _i <= _end; ++_i) {")
tabs_inc()
tabs_print("_str = sprintf(\"%s(%s) != %s\",")
tabs_print("_func_name, input_get(_i), output_get(_i))")
tabs_print("print sprintf(\"\\tif (%s)\", _str)")
tabs_print("print \"\\t\\terror(\\\"\" _str \"\\\")\"")
tabs_dec()
tabs_print("}")
tabs_dec()
print "}"
print "END { print \"}\"}"
print "/^[[:space:]]*#|^[[:space:]]*$/ {next}"
print "{stm_next(the_stm, $1)}"
print_end()
print_nl()
print_generate()
}

function print_example_data() {
print "begin"
print "func_name abs"
print "input -5"
print "output 5"
print "input 10"
print "output 10"
print "generate"
print ""
print "begin"
print "func_name square"
print "input 5"
print "output 25"
print "input 6"
print "output 36"
print ""
print "# intentional error"
print "input 7"
print "output 94"
print "generate"
}
# </smpg_messages>
# ./src/_smpg_generate.awk
# <generate>
function generate_all() {
	generate_head()
	nl()
	generate_descr()
	nl()
	generate_other()
	nl()
	generate_templates_and_fsm()
	nl()
	generate_includes()
}
function nl() {out_append_str("")}
function generate_head() {
	out_append_str("#!/usr/bin/awk -f")
	nl()
	out_append_str(sprintf("# generated by %s %s",
		SCRIPT_NAME(), SCRIPT_VERSION()))
}
function generate_descr_incl(    _arr, _len) {
	out_append_str("function DESCRIPT_INCLUDES() {")
	out_append_str("return \\")

	out_append_str("\"included files:\\n\"\\")
	_len = INCLUDE_get_file_names(_arr)
	arr_sub(_arr, _len, "^.*/", "\"")
	arr_sub(_arr, _len, "$", "\\n\"\\")
	out_append_arr(_arr, _len)

	out_append_str("}")
}
function generate_descr_fsm(    _arr, _len) {
	out_append_str("function DESCRIPT_FSM() {")
	out_append_str("return \\")

	out_append_str("\"fsm rules:\\n\"\\")

	_len = FSM_get_FSM_src(_arr)
	arr_sub(_arr, _len, "^", "\"")
	arr_sub(_arr, _len, "$", "\\n\"\\")
	out_append_arr(_arr, _len)
	out_append_str("\"\\n\"\\")
	out_append_str("\"'->' is read as 'must be followed by'\\n\"\\")
	out_append_str("\"'|' is read as 'or'\"")
	out_append_str("}")
}
function generate_descr(    _arr, _len) {
	out_append_str("# <description>")
	generate_descr_incl()
	generate_descr_fsm()
	out_append_str("function DESCRIPT() {")
	out_append_str("\treturn (DESCRIPT_INCLUDES() \"\\n\" DESCRIPT_FSM())")
	out_append_str("}")
	out_append_str("# </description>")
}
function generate_other() {
	out_append_str("# <other>")
	out_append_str(OTHER_get_src())
	out_append_str("# </other>")
}
function generate_templates_and_fsm(    _arr_fsm_src, _arr, _len) {

	_len = FSM_get_FSM_src(_arr_fsm_src)
	_len = fsm_make(_arr, _arr_fsm_src, _len, FSM_get_name(),
		FSM_EVENT())

	if (!_len)
		equit(sprintf("fsm: %s", _arr[2]), FSM_get_line_no(_arr[1]))

	enrich_templates_and_handlers(_arr, _len)
	out_append_arr(_arr, _len)
}
function enrich_templates_and_handlers(arr, len,    _arr_hndl_ind,
_arr_nm, _arr_nm_cpy, _len_nm, _i, _end, _j, _name, _rx, _prep_map,
_args, _hind, _tmplt, _arr_rxs) {


	_end = get_handler_start(_arr_hndl_ind, arr, len)
	_len_nm = get_handler_names(_arr_nm, arr, _arr_hndl_ind, _end)
	arr_copy(_arr_nm_cpy, _arr_nm, _len_nm)

	_end = TEMPLATE_get_rx_all(_arr_rxs)
	if (_end) {
		_tmplt = "# <templated>"

		for (_i = 1; _i <= _end; ++_i) {

			_rx = _arr_rxs[_i]
			_tmplt = (_tmplt "\n" sprintf("# '%s'", _rx))
			for (_j = 1; _j <= _len_nm; ++_j) {

				_name = _arr_nm_cpy[_j]
				if (_name && match(_name, _rx)) {
					_arr_nm_cpy[_j] = ""

					_hind = _arr_hndl_ind[_j]
					_prep_map["&"] = _name
					_tmplt = (_tmplt "\n"\
						prep_str(TEMPLATE_get_rx_src(_rx), _prep_map) \
						"\n")
				}
			}
		}
		_tmplt = (_tmplt "# </templated>\n")
		arr[1] = (_tmplt "\n" arr[1])
	}

	_end = HANDLER_get_rx_all(_arr_rxs)
	if (_end) {
		for (_i = 1; _i <= _end; ++_i) {

			_rx = _arr_rxs[_i]
			_args = HANDLER_get_rx_args(_rx)
			for (_j = 1; _j <= _len_nm; ++_j) {

				_name = _arr_nm[_j]
				if (_name && match(_name, _rx)) {
					_arr_nm[_j] = ""

					_hind = _arr_hndl_ind[_j]
					if (_args) {
						sub("\\)", sprintf("    %s)", _args),
							arr[_hind])
					}

					_prep_map["&"] = _name
					arr[_hind+1] = prep_str(HANDLER_get_rx_src(_rx),
						_prep_map)
				}
			}
		}
	}
}
function get_handler_start(arr_out, arr, len) {
	return arr_match_ind_all(arr_out, arr, len, "function .*on_")
}
function get_handler_names(arr_out, arr_src, arr_ind, ind_len) {
	arr_gather(arr_out, arr_src, arr_ind, ind_len)
	arr_gsub(arr_out, ind_len, "function .*on_|\\(.*$", "")
	return ind_len
}
function generate_includes(    _i, _end, _arr, _len, _fname) {
	out_append_str("# <includes>")

	_end = INCLUDE_get_num()
	for(_i = 1; _i <= _end; ++_i) {

		_fname = INCLUDE_get_fname(_i)
		out_append_str(sprintf("# %s", _fname))

		_len = read_file(_fname, _arr)
		if (_len < 0) {
			equit(sprintf("reading '%s': %s", _fname, ERRNO),
				INCLUDE_get_line_no(_i))
		}

		out_append_arr(_arr, _len)
	}

	out_append_str("# </includes>")
}
# </generate>
# ../awklib/src/awklib_fsm.awk
#@ <awklib_fsm>
#@ Library: fsm
#@ Description: Generates awk source code for finite state machines.
#@ Takes input in the form of:
#@ 'x -> y' or 'x -> y | z | ...'
#@ where 'x', 'y', and 'z' are states. '->' is read as 'is followed by'.
#@ '|' is read as 'or'. A state must be followed by one or more states.
#@
#@ Two kinds of state machines can be generated - an event fsm and a
#@ loop fsm. The event fsm generates events on each state transition.
#@ E.g. given
#@
#@ a -> b | c
#@ b -> c
#@ c -> a
#@
#@ an event fsm will start in the implicit empty state. From there the
#@ user requests state changes by calling the 'next()' function with the
#@ desired next state as an argument. From the empty state, the fsm will
#@ be able to go only to state 'a' and the 'on_a()' handler will be
#@ called before the state switch. From state 'a', the fsm will be able
#@ to go only to state 'b', or 'c', calling 'on_b()', or 'on_c()',
#@ respectively, etc. If an invalid state is requested, e.g. trying to
#@ switch to any other state than 'c' while in state 'b', the error
#@ handler will be called. All handlers are user defined. Note that
#@ there cannot be a state which does not lead to another state. The
#@ pattern for an event machine is usually circular, i.e. the last state
#@ goes to the first. This is awkward when not needed but keeps the
#@ implementation simple. Usually initialization is done in the first
#@ state and all processing in the last. There is an advantage - the
#@ user can check if the final state was reached in the END {} awk rule.
#@
#@ The loop fsm is different. No internal logic for state switching
#@ is provided. Instead, the states are displayed as a series of ifs
#@ inside a loop. The conditions on which the states change, i.e. the if
#@ conditions, are left to the user to define.
#@
#@ While the event fsm is more convenient when you can use the state
#@ names directly, e.g. to recognize some declarative, line oriented
#@ syntax in a file by looking at the first field, the loop fsm is more
#@ convenient when some arbitrary, unrelated to the state names logic is
#@ required, e.g. to recognize valid quote enclosed strings character by
#@ character, like "ab\"c".
#@
#@ Note that the user is expected and encouraged to edit the generated
#@ fsm code to fit their specific needs. The purpose of this library is
#@ to spare most of the tedium.
#@
#@ Version: 1.0
##
## Vladimir Dinev
## vld.dinev@gmail.com
## 2021-08-27
#@

# <public>
#@ Description: When passed to 'fsm_make()' as the 'type' argument,
#@ an event fsm is generated.
#@ Returns: A string constant for the event type of fsm.
#
function FSM_EVENT() {return "event"}

#
#@ Description: When passed to 'fsm_make()' as the 'type' argument,
#@ a loop fsm is generated.
#@ Returns: A string constant for the loop type of fsm.
#
function FSM_LOOP() {return "loop"}

#
#@ Description: Clears 'arr_out', generates a fsm with a name 'name' of
#@ type 'type'. 'type' can be either FSM_EVENT(), or FSM_LOOP(). If
#@ neither, FSM_EVENT() is used. 'name' is used in the fsm function's
#@ names. If not given, "_" is used. 'arr_in' is an array of strings
#@ which describe a fsm as per this library documentation. 'len' is the
#@ length of 'arr_in'.
#@ Returns: The length of 'arr_out' on success. If a syntax, or a
#@ logical error in the input is encountered, 0 is returned. In the
#@ event of such an error, 'arr_out[1]' will contain the index of the
#@ offending line in 'arr_in' and 'arr_out[2]' will contain an error
#@ message string.
#
function fsm_make(arr_out, arr_in, len, name, type,    _arr_set, _str,
_fget_st, _fset_st, _st_static, _tabs, _i, _j, _arr_splt, _tmp,
_head, _tail, _bk0, _has0, _err_exp) {

	delete arr_out

	if ((FSM_EVENT() != type) && (FSM_LOOP() != type))
		type = FSM_EVENT()
	
	if (!name)
		name = "_"
	
	_tmp = _fsm_check_syntax(arr_out, arr_in, len, name, _arr_set)
	if (!_tmp)
		return 0
	
	_fsm_add_line(arr_out, sprintf("# <%s>", name))
	
	if (FSM_EVENT() == type) {
		_fsm_add_line(arr_out, "# <handlers>")
		_fsm_gen_handlers(arr_out, _arr_set, _tmp, name)
		_fsm_add_line(arr_out, "# </handlers>")
		_fsm_add_line(arr_out, "")
	}
	
	_fsm_add_line(arr_out, "# <constants>")
	_fsm_gen_const(arr_out, _arr_set, _tmp, name)
	
	_st_static = sprintf("_%s_STATE", toupper(name))
	_fsm_add_line(arr_out, sprintf("function %s() {return \"state\"}",
		_st_static))
	_fsm_add_line(arr_out, "# </constants>")
	
	_fsm_add_line(arr_out, "")
	
	_fget_st = (name "_get_state")
	_fset_st = (name "_set_state")
	
	_fsm_add_line(arr_out, "# <functions>")
	_fsm_add_line(arr_out, sprintf("function %s(%s) {return %s[%s()]}",
		_fget_st, name, name, _st_static))
		
	if (_has0 = (0 in arr_in))
		_bk0 = arr_in[0]
		
	if (FSM_LOOP() == type) {
	
		_fsm_add_line(arr_out,
			sprintf("function %s(%s, next_st) {%s[%s()] = next_st}",
			_fset_st, name, name, _st_static))
		
		_fsm_add_line(arr_out, "")
		
		_fsm_add_line(arr_out,
			sprintf("function %s_loop(    _st, _i, _end) {", name))
		_fsm_add_line(arr_out, "")
		
		_tabs = "\t"
		_fsm_add_line(arr_out,
			sprintf("%sfor (_i = 1; _i <= _end; ++_i) {", _tabs))
		_fsm_add_line(arr_out, "")
		
		_tabs = "\t\t"
		_fsm_add_line(arr_out, sprintf("%s_st = %s(%s)",
			_tabs, _fget_st, name))
		
		split(arr_in[1], _arr_splt, _FSM_HEAD())
		_head = _arr_splt[1]
			
		arr_in[0] = (_FSM_HEAD() _head)
		
		for (_i = 0; _i <= len; ++_i) {
			
			split(arr_in[_i], _arr_splt, _FSM_HEAD())
			_head = _arr_splt[1]
			_tail = _arr_splt[2]
			
			_fsm_add_line(arr_out, sprintf("%s%s (%s == _st) {",
				_tabs, (0 == _i) ? "if" : "else if",
				(0 == _i) ? "\"\"" : (_fsm_to_const(name, _head) "()")))
			
			_tabs = "\t\t\t"
			_tmp = split(_tail, _arr_splt, _FSM_TAIL())
			for (_j = 1; _j <= _tmp; ++_j) {
				
				_str = _arr_splt[_j]
				_fsm_add_line(arr_out, sprintf("%s%s (1) {",
					_tabs, (1 == _j) ? "if" : "else if",
					_fsm_to_const(name, _str)))
				
				_fsm_add_line(arr_out, "")
				
				_tabs = "\t\t\t\t"
				_fsm_add_line(arr_out,
					sprintf("%s%s(%s, %s())",
					_tabs, _fset_st, name, _fsm_to_const(name, _str)))
				
				_tabs = "\t\t\t"
				_fsm_add_line(arr_out, sprintf("%s}", _tabs))
			}
			
			_tabs = "\t\t"
			_fsm_add_line(arr_out, sprintf("%s}", _tabs))
		}
		_tabs = "\t"
		_fsm_add_line(arr_out, sprintf("%s}", _tabs))
		_fsm_add_line(arr_out, "}")
		
	} else if (FSM_EVENT() == type) {
		
		_tabs = "\t"
		
		_fsm_add_line(arr_out,
			sprintf("function _%s(%s, next_st) {%s[%s()] = next_st}",
			_fset_st, name, name, _st_static))
		
		_fsm_add_line(arr_out,
			sprintf("function %s_next(%s, next_st,    _st) {",
			name, name))
	
		_fsm_add_line(arr_out, "")
		_fsm_add_line(arr_out, sprintf("%s_st = %s(%s)",
			_tabs, _fget_st, name))
		
		split(arr_in[1], _arr_splt, _FSM_HEAD())
		_head = _arr_splt[1]
		
		arr_in[0] = (_FSM_HEAD() _head)
		
		for (_i = 0; _i <= len; ++_i) {
			
			split(arr_in[_i], _arr_splt, _FSM_HEAD())
			_head = _arr_splt[1]
			_tail = _arr_splt[2]
			
			_fsm_add_line(arr_out, sprintf("%s%s (%s == _st) {",
				_tabs, (0 == _i) ? "if" : "else if",
				(0 == _i) ? "\"\"" : (_fsm_to_const(name, _head) "()")))
			
			_tabs = "\t\t"
			_tmp = split(_tail, _arr_splt, _FSM_TAIL())
			for (_j = 1; _j <= _tmp; ++_j) {
				
				_str = _arr_splt[_j]
				_fsm_add_line(arr_out, sprintf("%s%s (%s() == next_st)",
					_tabs, (1 == _j) ? "if" : "else if",
					_fsm_to_const(name, _str)))
				
				_fsm_add_line(arr_out,
					sprintf("%s{%s_on_%s(); _%s(%s, next_st)}",
					_tabs, name, _str, _fset_st, name))
				
				if (1 == _j) {
					_err_exp = sprintf("%s()",
						_fsm_to_const(name, _str))
				} else {
					_err_exp = (_err_exp sprintf("\"|\"%s()",
						_fsm_to_const(name, _str)))
				}
				_tabs = "\t\t"
			}
			
			_fsm_add_line(arr_out, sprintf("%selse", _tabs))
			_fsm_add_line(arr_out,
				sprintf("%s{%s_on_error(_st, %s, next_st)}",
				_tabs, name, _err_exp))
			
			_tabs = "\t"
			_fsm_add_line(arr_out, sprintf("%s}", _tabs))
		}
		_fsm_add_line(arr_out, "}")
	}
	_fsm_add_line(arr_out, "# </functions>")	
	_fsm_add_line(arr_out, sprintf("# </%s>", name))
	
	if (_has0)
		arr_in[0] = _bk0
	else
		delete arr_in[0]
	
	_tmp = _fsm_get_num_lines(arr_out)
	_fsm_clean_arr(arr_out)
	return _tmp
}
# </public>

function _fsm_gen_handlers(arr_out, arr_in, len, name,    _i,
_str) {

	for (_i = 1; _i <= len; ++_i) {
		_str = arr_in[_i]
		_fsm_add_line(arr_out, sprintf("function %s_on_%s() {", name,
			_str))
		_fsm_add_line(arr_out, "")
		_fsm_add_line(arr_out, "}")
	}
	_fsm_add_line(arr_out,
		sprintf("function %s_on_error(curr_st, expected, got) {", name))
	_fsm_add_line(arr_out, "")
	_fsm_add_line(arr_out, "}")
}

function _fsm_gen_const(arr_out, arr_in, len, name,    _i, _str) {
	
	for (_i = 1; _i <= len; ++_i) {
		_str = arr_in[_i]
		_fsm_add_line(arr_out, sprintf("function %s() {return \"%s\"}",
			_fsm_to_const(name, _str), _str))
	}
}

function _fsm_clean_arr(arr) {

	if (_FSM_HEAD() in arr)
		delete arr[_FSM_HEAD()]
}
function _fsm_get_num_lines(arr) {return arr[_FSM_HEAD()]}
function _fsm_add_line(arr, str) {

	# reuse some constant for the line count
	arr[++arr[_FSM_HEAD()]] = str
}
function _fsm_to_const(name, str) {

	return sprintf("%s_%s", toupper(name), toupper(str))
}

function _fsm_check_syntax(arr_out, arr_in, len, name, arr_set,    _i,
_set, _arr_splt, _str, _tmp, _head, _tail, _j, _nout) {

	if (!len)
		return _fsm_noin(arr_out, 0)

	if (!match(name, _FSM_ID()))
		return _fsm_enoid(arr_out, 0, name)
	
	_nout = 0
	for (_i = 1; _i <= len; ++_i) {
		
		_str = arr_in[_i]
		gsub("[[:space:]]+", "", _str)
		arr_in[_i] = _str
		
		_tmp = split(_str, _arr_splt, _FSM_HEAD())
		if (_tmp != 2 || !_arr_splt[_tmp])
			return _fsm_ebad_sep(arr_out, _i)
		
		_head = _arr_splt[1]
		_tail = _arr_splt[2]
		
		if (!match(_head, _FSM_ID()))
			return _fsm_enoid(arr_out, _i, _head)
			
		if (_head in _set)
			return _fsm_eredfn(arr_out, _i, _head)	
		++_set[_head]
		arr_set[++_nout] = _head
		
		_tmp = split(_tail, _arr_splt, _FSM_TAIL())
		if (!_arr_splt[_tmp])
			return _fsm_ebad_sep(arr_out, _i)
	}
	
	for (_i = 1; _i <= len; ++_i) {
		
		split(arr_in[_i], _arr_splt, _FSM_HEAD())
		_tail = _arr_splt[2]
		_tmp = split(_tail, _arr_splt, _FSM_TAIL())
		for (_j = 1; _j <= _tmp; ++_j) {
			
			_str = _arr_splt[_j]
			if (!(_str in _set))
				return _fsm_enodfn(arr_out, _i, _str)
			else
				++_set[_str]
		}
	}
	
	for (_i = 1; _i <= len; ++_i) {
		
		split(arr_in[_i], _arr_splt, _FSM_HEAD())
		_head = _arr_splt[1]
		
		if (1 == _set[_head])
			return _fsm_enoreach(arr_out, _i, _head)
	}
	
	return _nout
}

function _fsm_enoreach(arr_out, ind, str) {
	return _fsm_err(arr_out, ind,
		sprintf("state '%s' unreachable", str))
}
function _fsm_enoid(arr_out, ind, str) {
	return _fsm_err(arr_out, ind,
		sprintf("'%s' does not match '%s'", str, _FSM_ID()))
}
function _fsm_enodfn(arr_out, ind, str) {
	return _fsm_err(arr_out, ind,
		sprintf("state '%s' not defined", str))
}
function _fsm_eredfn(arr_out, ind, str) {
	return _fsm_err(arr_out, ind,
		sprintf("state '%s' redefined", str))
}
function _fsm_ebad_sep(arr_out, ind) {
	return _fsm_err(arr_out, ind, "bad separator")
}
function _fsm_noin(arr_out, ind) {
	return _fsm_err(arr_out, ind, "no input")
}
function _fsm_err(arr_out, ind, str) {
	arr_out[1] = ind
	arr_out[2] = str
	return 0
}

function _FSM_ID() {return "^[_[:alpha:]][_[:alnum:]]*$"}
function _FSM_HEAD() {return "->"}
function _FSM_TAIL() {return "\\|"}
#@ </awklib_fsm>
# ../awklib/src/awklib_array.awk
#@ <awklib_array>
#@ Library: arr
#@ Description: Array functionality.
#@ Version: 1.0
##
## Vladimir Dinev
## vld.dinev@gmail.com
## 2021-08-20
#@

#
#@ Description: Clears 'arr'.
#@ Returns: Nothing.
#@ Complexity: O(1)
#
function arr_init(arr) {

	arr[""]
	delete arr
}

#
#@ Description: Clears 'arr_dest', puts all keys of 'map' in 'arr_dest'.
#@ Returns: Nothing.
#@ Complexity: O(n)
#
function arr_from_map_keys(arr_dest, map,    _i, _n) {
	
	delete arr_dest
	_i = 0
	for (_n in map)
		arr_dest[++_i] = _n
	return _i
}

#
#@ Description: Clears 'arr_dest', puts all values of 'map' in
#@ 'arr_dest'.
#@ Returns: Nothing.
#@ Complexity: O(n)
#
function arr_from_map_vals(arr_dest, map,    _i, _n) {
	
	delete arr_dest
	_i = 0
	for (_n in map)
		arr_dest[++_i] = map[_n]
	return _i
}

#
#@ Description: Clears 'arr_dest' and copies the range defined by
#@ 'src_begin' and 'src_end' from 'arr_src' to 'arr_dest'. The range is
#@ inclusive. If 'src_begin' is larger than 'src_end', nothing is
#@ copied.
#@ Returns: The length of 'arr_dest'.
#@ Complexity: O(n)
#
function arr_range(arr_dest, arr_src, src_begin, src_end,    _i, _n) {
	
	delete arr_dest
	_n = 0
	for (_i = src_begin; _i <= src_end; ++_i)
		arr_dest[++_n] = arr_src[_i]
	return _n
}

#
#@ Description: Clears 'arr_dest' and copies 'arr_src' into 'arr_dest'.
#@ Returns: The length of 'arr_dest'.
#@ Complexity: O(n)
#
function arr_copy(arr_dest, arr_src, src_len) {

	return arr_range(arr_dest, arr_src, 1, src_len)
}

#
#@ Description: Appends 'arr_src' to the end of 'arr_dest'.
#@ Returns: The length of 'arr_dest' after appending.
#@ Complexity: O(n)
#
function arr_append(arr_dest, dest_len, arr_src, src_len,    _i) {

	for (_i = 1; _i <= src_len; ++_i)
		arr_dest[++dest_len] = arr_src[_i]
	return dest_len
}

#
#@ Description: Clears 'arr_dest', places all elements from 'arr_src'
#@ which are at indexes contained in 'arr_ind' in 'arr_dest'. E.g. given
#@ 'arr_ind[1] = 5; arr_ind[2] = 6', 'arr_dest' will get
#@ 'arr_dest[1] = arr_src[5]; arr_dest[2] = arr_src[6]'
#@ Returns: The length of 'arr_dest'.
#@ Complexity: O(n)
#
function arr_gather(arr_dest, arr_src, arr_ind, ind_len,    _i, _n) {
	
	delete arr_dest
	_n = 0
	for (_i = 1; _i <= ind_len; ++_i)
		arr_dest[++_n] = arr_src[arr_ind[_i]]
	return _n
}

#
#@ Description: Finds the index of the first match for 'regex' in 'arr'.
#@ Returns: The index of the first match, 0 if not match is found.
#@ Complexity: O(n)
#
function arr_match_ind_first(arr, len, regex,    _i) {
	
	for (_i = 1; _i <= len; ++_i) {
		if (match(arr[_i], regex))
			return _i
	}
	return 0
}

#
#@ Description: Clears 'arr_dest', places the indexes for all matches
#@ for 'regex' in 'arr_src' in 'arr_dest'.
#@ Returns: The length of 'arr_dest'.
#@ Complexity: O(n)
#
function arr_match_ind_all(arr_dest, arr_src, src_len, regex,    _i,
_n) {
	
	delete arr_dest
	_n = 0
	for (_i = 1; _i <= src_len; ++_i) {
		if (match(arr_src[_i], regex))
			arr_dest[++_n] = _i
	}
	return _n
}

#
#@ Description: Clears 'arr_dest' and copies all elements which match
#@ 'regex' from 'arr_src' to 'arr_dest'.
#@ Returns: The length of 'arr_dest'.
#@ Complexity: O(n)
#
function arr_match(arr_dest, arr_src, src_len, regex,    _i, _n) {

	delete arr_dest
	_n = 0
	for (_i = 1; _i <= src_len; ++_i) {
		if (match(arr_src[_i], regex))
			arr_dest[++_n] = arr_src[_i]
	}
	return _n
}

#
#@ Description: Finds the index of the first non-match for 'regex' in
#@ 'arr'.
#@ Returns: The index of the first non-match, 0 if all match.
#@ Complexity: O(n)
#
function arr_dont_match_ind_first(arr, len, regex,    _i) {
	
	for (_i = 1; _i <= len; ++_i) {
		if (!match(arr[_i], regex))
			return _i
	}
	return 0
}

#
#@ Description: Clears 'arr_dest', places the indexes for all
#@ non-matches for 'regex' in 'arr_src' in 'arr_dest'.
#@ Returns: The length of 'arr_dest'.
#@ Complexity: O(n)
#
function arr_dont_match_ind_all(arr_dest, arr_src, src_len, regex,
    _i, _n) {
	
	delete arr_dest
	_n = 0
	for (_i = 1; _i <= src_len; ++_i) {
		if (!match(arr_src[_i], regex))
			arr_dest[++_n] = _i
	}
	return _n
}

#
#@ Description: Clears 'arr_dest' and copies all elements which do not
#@ match 'regex' from 'arr_src' to 'arr_dest'.
#@ Returns: The length of 'arr_dest'.
#@ Complexity: O(n)
#
function arr_dont_match(arr_dest, arr_src, src_len, regex,    _i, _n) {

	delete arr_dest
	_n = 0
	for (_i = 1; _i <= src_len; ++_i) {
		if (!match(arr_src[_i], regex))
			arr_dest[++_n] = arr_src[_i]
	}
	return _n
}

#
#@ Description: Calls 'sub()' for every element of 'arr' like
#@ 'sub(regex, subst, arr[i])'
#@ Returns: The number of substitutions made.
#@ Complexity: O(n)
#
function arr_sub(arr, len, regex, subst,    _i, _n) {

	_n = 0
	for (_i = 1; _i <= len; ++_i)
		_n += sub(regex, subst, arr[_i])
	return _n
}

#
#@ Description: Calls gsub() for every element of 'arr' like
#@ 'gsub(regex, subst, arr[i])'
#@ Returns: The number of substitutions made.
#@ Complexity: O(n)
#
function arr_gsub(arr, len, regex, subst,    _i, _n) {

	_n = 0
	for (_i = 1; _i <= len; ++_i)
		_n += gsub(regex, subst, arr[_i])
	return _n
}

#
#@ Description: Checks if 'arr_a' and 'arr_b' have the same elements.
#@ Returns: 1 if the arrays are equal, 0 otherwise.
#@ Complexity: O(n)
#
function arr_is_eq(arr_a, len_a, arr_b, len_b,    _i) {

	if (len_a != len_b)
		return 0
	for (_i = 1; _i <= len_a; ++_i) {
		if (arr_a[_i] != arr_b[_i])
			return 0
	}
	return 1
}

#
#@ Description: Finds 'val' in 'arr'.
#@ Returns: The index of 'val' if it's found, 0 otherwise.
#@ Complexity: O(n)
#
function arr_find(arr, len, val,    _i) {
	
	for (_i = 1; _i <= len; ++_i) {
		if (arr[_i] == val)
			return _i
	}
	return 0
}

#
#@ Description: Concatenates all elements of 'arr' into a single string.
#@ The elements are separated by 'sep'. It 'sep' is not given, " " is
#@ used. 'sep' does not appear after the last element.
#@ Returns: The string representation of 'arr'.
#@ Complexity: O(n)
#
function arr_to_str(arr, len, sep,    _i, _str) {
	
	if (len < 1)
		return ""
	
	if (!sep)
		sep = " "
		
	_str = arr[1]
	for (_i = 2; _i <= len; ++_i)
		_str = (_str sep arr[_i])
	
	return _str
}

#
#@ Description: Prints 'arr' to stdout.
#@ Returns: Nothing.
#@ Complexity: O(n)
#
function arr_print(arr, len, sep) {

	print arr_to_str(arr, len, sep)
}
#@ </awklib_array>
# ../awklib/src/awklib_vect.awk
#@ <awklib_vect>
#@ Library: vect
#@ Description: Vector functionality. A vector is as array which is
#@ aware of its own size.
#@ Dependencies: awklib_array.awk
#@ Version: 1.0
##
## Vladimir Dinev
## vld.dinev@gmail.com
## 2021-08-20
#@

#
#@ Description: Clears 'vect', initializes it with length 0.
#@ Returns: Nothing.
#@ Complexity: O(1)
#
function vect_init(vect) {

	vect[""]
	delete vect
	vect[_VECT_LEN()] = 0
}

#
#@ Description: Initializes 'vect' to a copy of 'arr'.
#@ Returns: Nothing.
#@ Complexity: O(n)
#
function vect_init_arr(vect, arr, len,    _i) {
	
	vect_init(vect)
	for (_i = 1; _i <= len; ++_i)
		vect[++vect[_VECT_LEN()]] = arr[_i]
}

#
#@ Description: Appends 'val' to 'vect'.
#@ Returns: Nothing.
#@ Complexity: O(1)
#
function vect_push(vect, val) {

	vect[++vect[_VECT_LEN()]] = val
}

#
#@ Description: Appends 'arr' to 'vect'.
#@ Returns: Nothing.
#@ Complexity: O(n)
#
function vect_push_arr(vect, arr, len,    _i) {

	for (_i = 1; _i <= len; ++_i)
		vect[++vect[_VECT_LEN()]] = arr[_i]
}

#
#@ Description: Retrieves the last value from 'vect'.
#@ Returns: The last element.
#@ Complexity: O(1)
#
function vect_peek(vect) {

	return vect[vect[_VECT_LEN()]]
}

#
#@ Description: Removes the last element of 'vect'.
#@ Returns: Nothing.
#@ Complexity: O(1)
#
function vect_pop(vect) {

	vect[--vect[_VECT_LEN()]]
}

#
#@ Description: Provides the length.
#@ Returns: The length of 'vect'.
#@ Complexity: O(1)
#
function vect_len(vect) {
	
	return vect[_VECT_LEN()]
}

#
#@ Description: Indicates if 'vect' is empty or not.
#@ Returns: 1 if 'vect' is empty, 0 otherwise.
#@ Complexity: O(1)
#
function vect_is_empty(vect) {

	return (!vect[_VECT_LEN()])
}

#
#@ Description: Removes the element in 'vect' at index 'ind' by moving
#@ all further elements one to the left.
#@ Returns: Nothing.
#@ Complexity: O(n)
#
function vect_del_ind(vect, ind,    _i, _len) {
	
	_len = vect[_VECT_LEN()]
	for (_i = ind; _i < _len; ++_i)
		vect[_i] = vect[_i+1]
	--vect[_VECT_LEN()]
}

#
#@ Description: Removes 'val' from 'vect' by  if (arr_find())
#@ vect_del_ind().
#@ Returns: Nothing.
#@ Complexity: O(n)
#
function vect_del_val(vect, val,    _ind) {
	
	if (_ind = arr_find(vect, vect[_VECT_LEN()], val))
		vect_del_ind(vect, _ind)
}

#
#@ Description: Removes the element at 'ind' from 'vect' by replacing it
#@ with the last element.
#@ Returns: Nothing
#@ Complexity: O(1)
#
function vect_swap_pop_ind(vect, ind) {
	
	vect[ind] = vect[vect[_VECT_LEN()]]
	--vect[_VECT_LEN()]
}

#
#@ Description: Removes the first instance of 'val' from 'vect' by
#@ if (arr_find()) vect_swap_pop_ind().
#@ Returns: Nothing.
#@ Complexity: O(1)
#
function vect_swap_pop_val(vect, val, _ind) {

	if (_ind = arr_find(vect, vect[_VECT_LEN()], val))
		vect_swap_pop_ind(vect, _ind)
}

function _VECT_LEN() {return "len"}
#@ </awklib_vect>
# ../awklib/src/awklib_prep.awk
#@ <awklib_prep>
#@ Library: prep
#@ Description: Prepares strings by replacing named arguments.
#@ By default, the argument needs to appear between '{}' and can be any
#@ string. The argument name is matched as a regular expression. I.e.
#@ the default format for the named arguments is the printf string
#@ "[{]%s[}]" which, after being processed by 'sprintf()', is matched as
#@ a regular expression. The '[]' are needed to make sure the '{}' are
#@ matched literally, and the '%s' is the argument name. The '%s' is
#@ replaced by each argument name and the whole expression is replaced,
#@ if matched in the target string, by the argument value.
#@ E.g.:
#@
#@ Given the string:
#@
#@ "{1} quick {color} {ANIMAL} jumps over {1} lazy dog"
#@
#@ and the map:
#@
#@ m["1"] = "the"
#@ m["color"] = "brown"
#@ m["[A-Z]+"] = "fox"
#@
#@ the result is:
#@
#@ "the quick brown fox jumps over the lazy dog"
#@
#@ Note that only the '%s' part of the argument name needs to appear as
#@ an index in the map.
#@ Version: 1.0
##
## Vladimir Dinev
## vld.dinev@gmail.com
## 2021-08-29
#@

# <public>
#@ Description: The argument format as a printf string.
#@ Returns: The default value for the argument format.
#
function PREP_ARG() {return "[{]%s[}]"}

#
#@ Description: Replaces the named arguments in 'str' according to
#@ 'map'. E.g. if 'str' is "{1} {arg}" and 'map' is 'map[1] = "foo"'
#@ 'map["arg"] = "bar"', the result is "foo bar". If 'fmt' is not given,
#@ 'PREP_ARG()' is used. If it is given, it must contain a single '%s',
#@ which shall be replaced by the argument name. The '%s' can be
#@ surrounded by non printf string specifier.
#@ Returns: 'str' after all arguments found in 'map' have been replaced.
#
function prep_str(str, map, fmt) {

	if (!fmt)
		fmt = PREP_ARG()

	return _prep_str(str, map, fmt)
}

#
#@ Description: Indicates how many substitutions were made in the last
#@ call to 'prep_str()'
#@ Returns: The number of substitutions made.
#
function prep_num_of_subs() {return __LB_prep_number_of_substitutions__}
# </public>

function _prep_str(str, map, fmt,    _n, _subs) {
	
	_subs = 0
	for (_n in map)
		_subs += gsub(sprintf(fmt, _n), map[_n], str)
	_prep_set_subs(_subs)
	return str
}

function _prep_set_subs(n) {__LB_prep_number_of_substitutions__ = n}

#@ </awklib_prep>
# ../awklib/src/awklib_tabs.awk
#@ <awklib_tabs>
#@ Library: tabs
#@ Description: String indentation.
#@ Version: 1.0
##
## Vladimir Dinev
## vld.dinev@gmail.com
## 2021-08-16
#@

#
#@ Description: Adds a tab to the indentation string.
#@ Returns: Nothing.
#
function tabs_inc() {

	++__LB_tabs_tabs_num__
	__LB_tabs_tabs_str__ = (__LB_tabs_tabs_str__ "\t")
}

#
#@ Description: Removes a tab from the indentation string.
#@ Returns: Nothing.
#
function tabs_dec() {

	if (__LB_tabs_tabs_num__) {
		--__LB_tabs_tabs_num__
		__LB_tabs_tabs_str__ = substr(__LB_tabs_tabs_str__, 1,
			__LB_tabs_tabs_num__)
	}
}

#
#@ Description: Indicates the tab level.
#@ Returns: The number of tabs used for indentation.
#
function tabs_num() {

	return __LB_tabs_tabs_num__
}

#
#@ Description: Provides all indentation tabs as a string.
#@ Returns: The indentation string.
#
function tabs_get() {

	return (__LB_tabs_tabs_str__ "")
}

#
#@ Description: Adds indentation to 'str'.
#@ Returns: 'str' prepended with the current number of tabs.
#
function tabs_indent(str) {

	return (__LB_tabs_tabs_str__ str)
}

#
#@ Description: Prints the indented 'str' to stdout without a new line
#@ at the end.
#@ Returns: Nothing.
#
function tabs_print_str(str) {

	printf("%s", tabs_indent(str))
}

#
#@ Description: Prints the indented 'str' to stdout with a new line at
#@ the end.
#@ Returns: Nothing.
#
function tabs_print(str) {

	print tabs_indent(str)
}
#@ </awklib_tabs>
# ../awklib/src/awklib_prog.awk
#@ <awklib_prog>
#@ Library: prog
#@ Description: Provides program name, error, and exit handling. Unlike
#@ other libraries, the function names for this library are not
#@ prepended.
#@ Version 1.0
##
## Vladimir Dinev
## vld.dinev@gmail.com
## 2021-08-15
#@

#
#@ Description: Sets the program name to 'str'. This name can later be
#@ retrieved by get_program_name().
#@ Returns: Nothing.
#
function set_program_name(str) {

	__LB_prog_program_name__ = str
}

#
#@ Description: Provides the program name.
#@ Returns: The name as set by set_program_name().
#
function get_program_name() {

	return __LB_prog_program_name__
}

#
#@ Description: Prints 'msg' to stderr.
#@ Returns: Nothing.
#
function pstderr(msg) {

	print msg > "/dev/stderr"
}

#
#@ Description: Sets a static flag which can later be checked by
#@ should_skip_end().
#@ Returns: Nothing.
#
function skip_end_set() {

	__LB_prog_skip_end_flag__ = 1
}

#
#@ Description: Clears the flag set by skip_end_set().
#@ Returns: Nothing.
#
function skip_end_clear() {

	__LB_prog_skip_end_flag__ = 0
}

#
#@ Description: Checks the static flag set by skip_end_set().
#@ Returns: 1 if the flag is set, 0 otherwise.
#
function should_skip_end() {

	return (__LB_prog_skip_end_flag__+0)
}

#
#@ Description: Sets a static flag which can later be checked by
#@ did_error_happen().
#@ Returns: Nothing
#
function error_flag_set() {

	__LB_prog_error_flag__ = 1
}

#
#@ Description: Clears the flag set by error_flag_set().
#@ Returns: Nothing
#
function error_flag_clear() {

	__LB_prog_error_flag__ = 0
}

#
#@ Description: Checks the static flag set by error_flag_set().
#@ Returns: 1 if the flag is set, 0 otherwise.
#
function did_error_happen() {

	return (__LB_prog_error_flag__+0)
}

#
#@ Description: Sets the skip end flag, exits with error code 0.
#@ Returns: Nothing.
#
function exit_success() {
	
	skip_end_set()
	exit(0)
}

#
#@ Description: Sets the skip end flag, exits with 'code', or 1 if 'code' is 0
#@ or not given.
#@ Returns: Nothing.
#
function exit_failure(code) {

	skip_end_set()
	exit((code+0) ? code : 1)
}

#
#@ Description: Prints '<program-name>: error: msg' to stderr. Sets the
#@ error and skip end flags.
#@ Returns: Nothing.
#
function error_print(msg) {

	pstderr(sprintf("%s: error: %s", get_program_name(), msg))
	error_flag_set()
	skip_end_set()
}

#
#@ Description: Calls error_print() and quits with failure.
#@ Returns: Nothing.
#
function error_quit(msg, code) {

	error_print(msg)
	exit_failure(code)
}
#@ </awklib_prog>
# ../awklib/src/awklib_read.awk
#@ <awklib_read>
#@ Library: read
#@ Description: Read lines or a file into an array.
#@ Version: 1.0
##
## Vladimir Dinev
## vld.dinev@gmail.com
## 2021-08-15
#@

#
#@ Description: Clears 'arr_out', reads 'fname' and saves the content in 
#@ 'arr_our'. 
#@ Returns: The number of lines read, which is also the length of
#@ 'arr_out', or less than 0 if an error has occurred.
#
function read_file(fname, arr_out,    _line, _i, _code) {

	delete arr_out
	_i = 0
	
	while ((_code = (getline _line < fname)) > 0)
		arr_out[++_i] = _line
	
	if (_code < 0)
		return _code
	
	close(fname)
	return _i
}

#
#@ Description: Clears 'arr_out', calls 'getline' and saves the lines
#@ read in 'arr_out'. If 'rx_until' is given, reading stops when a line
#@ matches 'rx_until'. The matched line is not saved. If 'rx_ignore' is
#@ given, only lines which do not match 'rx_ignore' are saved. If
#@ 'rx_until' and 'rx_ignore' are the same, only 'rx_until' is
#@ considered.
#@ Returns: The length of 'arr_out', or < 0 on error.
#
function read_lines(arr_out, rx_until, rx_ignore,    _line, _i,
_code) {

	delete arr_out
	_i = 0
	
	while ((_code = (getline _line)) > 0) {
		
		if (rx_until && match(_line, rx_until))
			break
		
		if (rx_ignore && match(_line, rx_ignore))
			continue
			
		arr_out[++_i] = _line
	}
	
	if (_code < 0)
		return _code
		
	return _i
}
#@ </awklib_read>
# </includes>
