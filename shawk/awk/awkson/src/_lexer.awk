# <lex_awk>
# generated by lex-awk.awk 1.412

# <lex_usr_defined>
# The user implements the following:
# _lex_usr_get_line()
# _lex_usr_on_unknown_ch()
# _lex_usr_get_string()
# _lex_usr_get_number()
# _lex_usr_get_kword()
# </lex_usr_defined>

# <lex_public>
# <lex_constants>

# the only way to have immutable values; use as constants
function _TOK_LCURL() {return "{"}
function _TOK_RCURL() {return "}"}
function _TOK_LSQR() {return "["}
function _TOK_RSQR() {return "]"}
function _TOK_COLON() {return ":"}
function _TOK_COMMA() {return ","}
function _TOK_EOI() {return "EOI"}
function _TOK_TRUE() {return "true"}
function _TOK_FALSE() {return "false"}
function _TOK_NULL() {return "null"}
function _TOK_STRING() {return "string"}
function _TOK_NUMBER() {return "number"}
function _TOK_ERROR() {return "I am Error"}

function _CH_CLS_SPACE() {return 1}
function _CH_CLS_QUOTE() {return 2}
function _CH_CLS_SIGN() {return 3}
function _CH_CLS_NUMBER() {return 4}
function _CH_CLS_WORD() {return 5}
function _CH_CLS_NEW_LINE() {return 6}
function _CH_CLS_EOI() {return 7}
function _CH_CLS_AUTO_1_() {return 8}
function _CH_CLS_AUTO_2_() {return 9}
function _CH_CLS_AUTO_3_() {return 10}
function _CH_CLS_AUTO_4_() {return 11}
function _CH_CLS_AUTO_5_() {return 12}
function _CH_CLS_AUTO_6_() {return 13}
# </lex_constants>

# read the next character; advance the input
function _lex_read_ch() {
	# Note: the user defines _lex_usr_get_line()

	_B__lex_curr_ch = _B__lex_input_line[_B__lex_line_pos++]
	_B__lex_peek_ch = _B__lex_input_line[_B__lex_line_pos]
	if (_B__lex_peek_ch != "")
		return _B__lex_curr_ch
	else
		split(_lex_usr_get_line(), _B__lex_input_line, "")
	return _B__lex_curr_ch
}

# return the last read character
function _lex_curr_ch()
{return _B__lex_curr_ch}

# return the next character, but do not advance the input
function _lex_peek_ch()
{return _B__lex_peek_ch}

# return the position in the current line of input
function _lex_get_pos()
{return (_B__lex_line_pos-1)}

# return the current line number
function _lex_get_line_no()
{return _B__lex_line_no}

# return the last read token
function _lex_curr_tok()
{return _B__lex_curr_tok}

# see if your token is the same as the one in the lexer
function _lex_match_tok(str)
{return (str == _B__lex_curr_tok)}

# clear the lexer write space
function _lex_save_init()
{_B__lex_saved = ""}

# save the last read character
function _lex_save_curr_ch()
{_B__lex_saved = (_B__lex_saved _B__lex_curr_ch)}

# return the saved string
function _lex_get_saved()
{return _B__lex_saved}

# character classes
function _lex_is_ch_cls(ch, cls)
{return (cls == _B__lex_ch_tbl[ch])}

function _lex_is_curr_ch_cls(cls)
{return (cls == _B__lex_ch_tbl[_B__lex_curr_ch])}

function _lex_is_next_ch_cls(cls)
{return (cls == _B__lex_ch_tbl[_B__lex_peek_ch])}

function _lex_get_ch_cls(ch)
{return _B__lex_ch_tbl[ch]}

# see if what's in the lexer's write space is a keyword
function _lex_is_saved_a_keyword()
{return (_B__lex_saved in _B__lex_keywords_tbl)}

# call this first
function _lex_init() {
	# '_B' variables are 'bound' to the lexer, i.e. 'private'
	if (!_B__lex_are_tables_init) {
		__lex_init_ch_tbl()
		__lex_init_keywords()
		_B__lex_are_tables_init = 1
	}
	_B__lex_curr_ch = ""
	_B__lex_curr_ch_cls_cache = ""
	_B__lex_curr_tok = "I am Error"
	_B__lex_line_no = 1
	_B__lex_line_pos = 1
	_B__lex_peek_ch = ""
	_B__lex_peeked_ch_cache = ""
	_B__lex_saved = ""
	split(_lex_usr_get_line(), _B__lex_input_line, "")
}

# return the next token; constants are inlined for performance
function _lex_next() {
	_B__lex_curr_tok = "I am Error"
	while (1) {
		_B__lex_curr_ch_cls_cache = _B__lex_ch_tbl[_lex_read_ch()]
		if (1 == _B__lex_curr_ch_cls_cache) { # _CH_CLS_SPACE()
			continue
		} else if (2 == _B__lex_curr_ch_cls_cache) { # _CH_CLS_QUOTE()
			_B__lex_curr_tok = _lex_usr_get_string()
		} else if (3 == _B__lex_curr_ch_cls_cache) { # _CH_CLS_SIGN()
			_B__lex_curr_tok = _lex_usr_get_number()
		} else if (4 == _B__lex_curr_ch_cls_cache) { # _CH_CLS_NUMBER()
			_B__lex_curr_tok = _lex_usr_get_number()
		} else if (5 == _B__lex_curr_ch_cls_cache) { # _CH_CLS_WORD()
			_B__lex_curr_tok = _lex_usr_get_kword()
		} else if (6 == _B__lex_curr_ch_cls_cache) { # _CH_CLS_NEW_LINE()
			++_B__lex_line_no
			_B__lex_line_pos = 1
			continue
		} else if (7 == _B__lex_curr_ch_cls_cache) { # _CH_CLS_EOI()
			_B__lex_curr_tok = _TOK_EOI()
		} else if (8 == _B__lex_curr_ch_cls_cache) { # _CH_CLS_AUTO_1_()
			_B__lex_curr_tok = "{"
		} else if (9 == _B__lex_curr_ch_cls_cache) { # _CH_CLS_AUTO_2_()
			_B__lex_curr_tok = "}"
		} else if (10 == _B__lex_curr_ch_cls_cache) { # _CH_CLS_AUTO_3_()
			_B__lex_curr_tok = "["
		} else if (11 == _B__lex_curr_ch_cls_cache) { # _CH_CLS_AUTO_4_()
			_B__lex_curr_tok = "]"
		} else if (12 == _B__lex_curr_ch_cls_cache) { # _CH_CLS_AUTO_5_()
			_B__lex_curr_tok = ":"
		} else if (13 == _B__lex_curr_ch_cls_cache) { # _CH_CLS_AUTO_6_()
			_B__lex_curr_tok = ","
		} else {
			_B__lex_curr_tok = _lex_usr_on_unknown_ch()
		}
		break
	}
	return _B__lex_curr_tok
}
# </lex_public>

# <lex_private>
# initialize the lexer tables
function __lex_init_keywords() {
	_B__lex_keywords_tbl["true"] = 1
	_B__lex_keywords_tbl["false"] = 1
	_B__lex_keywords_tbl["null"] = 1
}
function __lex_init_ch_tbl() {
	_B__lex_ch_tbl[" "] = _CH_CLS_SPACE()
	_B__lex_ch_tbl["\t"] = _CH_CLS_SPACE()
	_B__lex_ch_tbl["\r"] = _CH_CLS_SPACE()
	_B__lex_ch_tbl["\""] = _CH_CLS_QUOTE()
	_B__lex_ch_tbl["-"] = _CH_CLS_SIGN()
	_B__lex_ch_tbl["+"] = _CH_CLS_SIGN()
	_B__lex_ch_tbl["0"] = _CH_CLS_NUMBER()
	_B__lex_ch_tbl["1"] = _CH_CLS_NUMBER()
	_B__lex_ch_tbl["2"] = _CH_CLS_NUMBER()
	_B__lex_ch_tbl["3"] = _CH_CLS_NUMBER()
	_B__lex_ch_tbl["4"] = _CH_CLS_NUMBER()
	_B__lex_ch_tbl["5"] = _CH_CLS_NUMBER()
	_B__lex_ch_tbl["6"] = _CH_CLS_NUMBER()
	_B__lex_ch_tbl["7"] = _CH_CLS_NUMBER()
	_B__lex_ch_tbl["8"] = _CH_CLS_NUMBER()
	_B__lex_ch_tbl["9"] = _CH_CLS_NUMBER()
	_B__lex_ch_tbl["a"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["b"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["c"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["d"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["e"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["f"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["g"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["h"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["i"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["j"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["k"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["l"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["m"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["n"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["o"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["p"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["q"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["r"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["s"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["t"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["u"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["v"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["w"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["x"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["y"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["z"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["A"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["B"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["C"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["D"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["E"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["F"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["G"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["H"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["I"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["J"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["K"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["L"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["M"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["N"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["O"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["P"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["Q"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["R"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["S"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["T"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["U"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["V"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["W"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["X"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["Y"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["Z"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["_"] = _CH_CLS_WORD()
	_B__lex_ch_tbl["\n"] = _CH_CLS_NEW_LINE()
	_B__lex_ch_tbl[""] = _CH_CLS_EOI()
	_B__lex_ch_tbl["{"] = _CH_CLS_AUTO_1_()
	_B__lex_ch_tbl["}"] = _CH_CLS_AUTO_2_()
	_B__lex_ch_tbl["["] = _CH_CLS_AUTO_3_()
	_B__lex_ch_tbl["]"] = _CH_CLS_AUTO_4_()
	_B__lex_ch_tbl[":"] = _CH_CLS_AUTO_5_()
	_B__lex_ch_tbl[","] = _CH_CLS_AUTO_6_()
}
# </lex_private>
# </lex_awk>
# <lex_usr_implemented>
function _TOK_ERR_UNKNOWN_CH() {return "unknown characters"}
function _TOK_ERR_BAD_STRING() {return "bad string"}
function _TOK_ERR_BAD_NUMBER() {return "bad number"}
function _TOK_ERR_BAD_SIGN() {return "bad sign"}
function _TOK_ERR_BAD_HEX_NUMBER() {return "bad hex number"}
function _TOK_ERR_BAD_ESC_SEQ() {return "bad escape sequence"}

function _lex_usr_on_unknown_ch() {
	_lex_save_init()
	_lex_save_curr_ch()

	while (!_lex_get_ch_cls(_lex_peek_ch())) {
		_lex_read_ch()
		_lex_save_curr_ch()
	}

	return _TOK_ERR_UNKNOWN_CH()
}

function _lex_usr_init_hex_digit() {
	_B_awkson_lex_hex_digit["0"] = 1
	_B_awkson_lex_hex_digit["1"] = 1
	_B_awkson_lex_hex_digit["2"] = 1
	_B_awkson_lex_hex_digit["3"] = 1
	_B_awkson_lex_hex_digit["4"] = 1
	_B_awkson_lex_hex_digit["5"] = 1
	_B_awkson_lex_hex_digit["6"] = 1
	_B_awkson_lex_hex_digit["7"] = 1
	_B_awkson_lex_hex_digit["8"] = 1
	_B_awkson_lex_hex_digit["9"] = 1
	_B_awkson_lex_hex_digit["a"] = 1
	_B_awkson_lex_hex_digit["b"] = 1
	_B_awkson_lex_hex_digit["c"] = 1
	_B_awkson_lex_hex_digit["d"] = 1
	_B_awkson_lex_hex_digit["e"] = 1
	_B_awkson_lex_hex_digit["f"] = 1
	_B_awkson_lex_hex_digit["A"] = 1
	_B_awkson_lex_hex_digit["B"] = 1
	_B_awkson_lex_hex_digit["C"] = 1
	_B_awkson_lex_hex_digit["D"] = 1
	_B_awkson_lex_hex_digit["E"] = 1
	_B_awkson_lex_hex_digit["F"] = 1
}
function _lex_usr_is_hex_digit(ch) {
	return (ch in _B_awkson_lex_hex_digit)
}

function _lex_usr_init_esc_chars() {
	_B_awkson_lex_esc_char["\""] = 1
	_B_awkson_lex_esc_char["\\"] = 1
	_B_awkson_lex_esc_char["/"] = 1
	_B_awkson_lex_esc_char["b"] = 1
	_B_awkson_lex_esc_char["f"] = 1
	_B_awkson_lex_esc_char["n"] = 1
	_B_awkson_lex_esc_char["r"] = 1
	_B_awkson_lex_esc_char["t"] = 1
	_B_awkson_lex_esc_char["u"] = 1
}
function _lex_usr_is_esc_char(ch) {
	return (ch in _B_awkson_lex_esc_char)
}

function _lex_get_line_str() {
	# exists generally for testing
	return _G_current_input_line
}
function _lex_usr_get_line() {
	# _B_getline_code avoids creating a private variable on each call
	_B_getline_code = (getline _G_current_input_line < get_file_name())
		
	if (_B_getline_code > 0) {
		return (_G_current_input_line "\n")
	} else if (0 == _B_getline_code) {
		return ""
	} else {
		error_quit(sprintf("file '%s': %s", get_file_name(), ERRNO))
	} 
}
function _lex_usr_get_string(    _curr_ch, _peek_ch) {
	_lex_save_init()

	# save the opening quote
	_lex_save_curr_ch()

	while (1) {
		_peek_ch = _lex_peek_ch()
		if ("\n" == _peek_ch || "" == _peek_ch)
			break

		_lex_read_ch()
		_lex_save_curr_ch()

		# _peek_ch is now the current char
		if ("\"" == _peek_ch)
			return _TOK_STRING()
			
		if ("\\" == _peek_ch) {
			
			_peek_ch = _lex_peek_ch()
			if (_lex_usr_is_esc_char(_peek_ch)) {
				
				# read and save the escaped character
				_lex_read_ch()
				_lex_save_curr_ch()
				
				if ("u" == _peek_ch) {
					# read four hex digits
					
					_lex_read_ch()
					if (_lex_usr_is_hex_digit(_lex_curr_ch()))
						_lex_save_curr_ch()
					else
						return _TOK_ERR_BAD_HEX_NUMBER()
					
					_lex_read_ch()
					if (_lex_usr_is_hex_digit(_lex_curr_ch()))
						_lex_save_curr_ch()
					else
						return _TOK_ERR_BAD_HEX_NUMBER()
					
					_lex_read_ch()
					if (_lex_usr_is_hex_digit(_lex_curr_ch()))
						_lex_save_curr_ch()
					else
						return _TOK_ERR_BAD_HEX_NUMBER()
					
					_lex_read_ch()
					if (_lex_usr_is_hex_digit(_lex_curr_ch()))
						_lex_save_curr_ch()
					else
						return _TOK_ERR_BAD_HEX_NUMBER()
				}
			} else {
				return _TOK_ERR_BAD_ESC_SEQ()
			}
		}
	}

	return _TOK_ERR_BAD_STRING()
}

function __lex_usr_get_int_part(    _digits) {
	_digits = 0
	while (_lex_is_next_ch_cls(_CH_CLS_NUMBER())) {
		_lex_read_ch()
		_lex_save_curr_ch()
		++_digits
	}
	return _digits
}
function _lex_usr_get_number(    _peek_ch) {
	_lex_save_init()

	_lex_save_curr_ch()
	if (_lex_is_curr_ch_cls(_CH_CLS_SIGN())) {
	
		if (_lex_curr_ch() == "-") {	
			# has to have a number after the sign
			if (!__lex_usr_get_int_part())
				return _TOK_ERR_BAD_NUMBER()
		} else {
			return _TOK_ERR_BAD_SIGN()
		}
	} else if (_lex_curr_ch() != "0"){
		# exactly one zero at the beginning allowed
		__lex_usr_get_int_part()
	}
	
	# optional fraction
	if (_lex_peek_ch() == ".") {
		_lex_read_ch()
		_lex_save_curr_ch()
		if (!__lex_usr_get_int_part())
			return _TOK_ERR_BAD_NUMBER()
	}

	# optional exponent
	_peek_ch = _lex_peek_ch()
	if ("e" == _peek_ch || "E" == _peek_ch) {
		_lex_read_ch()
		_lex_save_curr_ch()

		# optional sign
		if (_lex_is_next_ch_cls(_CH_CLS_SIGN())) {
			_lex_read_ch()
			_lex_save_curr_ch()
		}
		if (!__lex_usr_get_int_part())
			return _TOK_ERR_BAD_NUMBER()
	}

	return _TOK_NUMBER()
}

function _lex_usr_get_kword() {
	_lex_save_init()
	_lex_save_curr_ch()

	while (_lex_is_next_ch_cls(_CH_CLS_WORD())) {
		_lex_read_ch()
		_lex_save_curr_ch()
	}

	return (_lex_is_saved_a_keyword()) ? _lex_get_saved() : _TOK_ERROR()
}

function _lex_pretty_pos(line) {
	return (line "\n" _pretty_pos(line, _lex_get_pos()))
}
# </lex_usr_implemented>
