#!/usr/bin/awk -f

# generated by smpg.awk 2.0

# <description>
function DESCRIPT_INCLUDES() {
return \
"included files:\n"\
"awklib_prog.awk\n"\
}
function DESCRIPT_FSM() {
return \
"fsm rules:\n"\
"start  -> prefix | type\n"\
"prefix -> type\n"\
"type   -> has\n"\
"has    -> has | type | end\n"\
"end    -> start\n"\
"\n"\
"'->' is read as 'must be followed by'\n"\
"'|' is read as 'or'"
}
function DESCRIPT() {
	return (DESCRIPT_INCLUDES() "\n" DESCRIPT_FSM())
}
# </description>

# <other>
# Author: Vladimir Dinev
# vld.dinev@gmail.com
# 2024-08-03

function SCRIPT_NAME() {return "structs.awk"}
function SCRIPT_VERSION() {return "1.0"}

# <awk_rules>
function init() {
	set_program_name(SCRIPT_NAME())

	if (Fsm)
		print_fsm()
	if (Help)
		print_help()
	if (Version)
		print_version()
	if (ARGC != 2)
		print_use_try()
}
BEGIN {
	init()
}

# ignore empty lines and comments
/^[[:space:]]*(#|$)/ {next}

# strip spaces and fsm
{
	gsub("^[[:space:]]+|[[:space:]]+$", "", $0)
	fsm_next(G_the_fsm, $1)
}
# </awk_rules>

function data_or_err() {
	if (NF < 2)
		error_qfpos(sprintf("no data after '%s'", $1))
}
function error_qfpos(msg) {
	error_quit(sprintf("file '%s' line %d: %s", FILENAME, FNR, msg))
}
# </other>

# <templated>
# 'prefix|type|has'
function on_prefix(v) {prefix_save(v)}

function on_type(v) {type_save(v)}

function on_has(v) {has_save(v)}
# </templated>

# <fsm>
# <handlers>
function fsm_on_start() {
	prefix_save("ent")
}
function fsm_on_prefix() {
	data_or_err()
	on_prefix($2)
}
function fsm_on_type() {
	data_or_err()
	on_type($2)
}
function fsm_on_has() {
	data_or_err()
	on_has($2)
}
function fsm_on_end() {
	tag_open(tag_structs())
	generate()
	tag_close(tag_structs())
	exit_success()
}
function fsm_on_error(curr_st, expected, got) {
	error_qfpos(sprintf("'%s' expected, but got '%s' instead", expected, got))
}
# </handlers>

# <constants>
function FSM_START() {return "start"}
function FSM_PREFIX() {return "prefix"}
function FSM_TYPE() {return "type"}
function FSM_HAS() {return "has"}
function FSM_END() {return "end"}
function _FSM_STATE() {return "state"}
# </constants>

# <functions>
function fsm_get_state(fsm) {return fsm[_FSM_STATE()]}
function _fsm_set_state(fsm, next_st) {fsm[_FSM_STATE()] = next_st}
function fsm_next(fsm, next_st,    _st) {

	_st = fsm_get_state(fsm)
	if ("" == _st) {
		if (FSM_START() == next_st)
		{fsm_on_start(); _fsm_set_state(fsm, next_st)}
		else
		{fsm_on_error(_st, FSM_START(), next_st)}
	}
	else if (FSM_START() == _st) {
		if (FSM_PREFIX() == next_st)
		{fsm_on_prefix(); _fsm_set_state(fsm, next_st)}
		else if (FSM_TYPE() == next_st)
		{fsm_on_type(); _fsm_set_state(fsm, next_st)}
		else
		{fsm_on_error(_st, FSM_PREFIX()"|"FSM_TYPE(), next_st)}
	}
	else if (FSM_PREFIX() == _st) {
		if (FSM_TYPE() == next_st)
		{fsm_on_type(); _fsm_set_state(fsm, next_st)}
		else
		{fsm_on_error(_st, FSM_TYPE(), next_st)}
	}
	else if (FSM_TYPE() == _st) {
		if (FSM_HAS() == next_st)
		{fsm_on_has(); _fsm_set_state(fsm, next_st)}
		else
		{fsm_on_error(_st, FSM_HAS(), next_st)}
	}
	else if (FSM_HAS() == _st) {
		if (FSM_HAS() == next_st)
		{fsm_on_has(); _fsm_set_state(fsm, next_st)}
		else if (FSM_TYPE() == next_st)
		{fsm_on_type(); _fsm_set_state(fsm, next_st)}
		else if (FSM_END() == next_st)
		{fsm_on_end(); _fsm_set_state(fsm, next_st)}
		else
		{fsm_on_error(_st, FSM_HAS()"|"FSM_TYPE()"|"FSM_END(), next_st)}
	}
	else if (FSM_END() == _st) {
		if (FSM_START() == next_st)
		{fsm_on_start(); _fsm_set_state(fsm, next_st)}
		else
		{fsm_on_error(_st, FSM_START(), next_st)}
	}
}
# </functions>
# </fsm>

# <includes>
# ../awklib/src/awklib_prog.awk
#@ <awklib_prog>
#@ Library: prog
#@ Description: Provides program name, error, and exit handling.
#@ Version 1.0
##
## Vladimir Dinev
## vld.dinev@gmail.com
## 2021-08-15
#@

#
#@ Description: Sets the program name to 'str'. This name can later be
#@ retrieved by get_program_name().
#@ Returns: Nothing.
#
function set_program_name(str) {

	_AWKLIB_prog__program_name = str
}

#
#@ Description: Provides the program name.
#@ Returns: The name as set by set_program_name().
#
function get_program_name() {

	return _AWKLIB_prog__program_name
}

#
#@ Description: Prints 'msg' to stderr.
#@ Returns: Nothing.
#
function pstderr(msg) {

	print msg > "/dev/stderr"
}

#
#@ Description: Sets a static flag which can later be checked by
#@ should_skip_end().
#@ Returns: Nothing.
#
function skip_end_set() {

	_AWKLIB_prog__skip_end_flag = 1
}

#
#@ Description: Clears the flag set by skip_end_set().
#@ Returns: Nothing.
#
function skip_end_clear() {

	_AWKLIB_prog__skip_end_flag = 0
}

#
#@ Description: Checks the static flag set by skip_end_set().
#@ Returns: 1 if the flag is set, 0 otherwise.
#
function should_skip_end() {

	return (_AWKLIB_prog__skip_end_flag+0)
}

#
#@ Description: Sets a static flag which can later be checked by
#@ did_error_happen().
#@ Returns: Nothing
#
function error_flag_set() {

	_AWKLIB_prog__error_flag = 1
}

#
#@ Description: Clears the flag set by error_flag_set().
#@ Returns: Nothing
#
function error_flag_clear() {

	_AWKLIB_prog__error_flag = 0
}

#
#@ Description: Checks the static flag set by error_flag_set().
#@ Returns: 1 if the flag is set, 0 otherwise.
#
function did_error_happen() {

	return (_AWKLIB_prog__error_flag+0)
}

#
#@ Description: Sets the skip end flag, exits with error code 0.
#@ Returns: Nothing.
#
function exit_success() {

	skip_end_set()
	exit(0)
}

#
#@ Description: Sets the skip end flag, exits with 'code', or 1 if 'code' is 0
#@ or not given.
#@ Returns: Nothing.
#
function exit_failure(code) {

	skip_end_set()
	exit((code+0) ? code : 1)
}

#
#@ Description: Prints '<program-name>: error: msg' to stderr. Sets the
#@ error and skip end flags.
#@ Returns: Nothing.
#
function error_print(msg) {

	pstderr(sprintf("%s: error: %s", get_program_name(), msg))
	error_flag_set()
	skip_end_set()
}

#
#@ Description: Calls error_print() and quits with failure.
#@ Returns: Nothing.
#
function error_quit(msg, code) {

	error_print(msg)
	exit_failure(code)
}
#@ </awklib_prog>
# </includes>
# <generate>
# <data>
function _set(k, v) {_B_structs[k] = v}
function _get(k) {return _B_structs[k]}

function prefix_save(str) {_set("prefix", str)}
function prefix_get() {return _get("prefix")}

function type_save(str,    _n) {
	_set("type.count", (_n = _get("type.count")+1))
	_set(sprintf("type=%d", _n), str)
}
function type_count() {return _get("type.count")}
function type_get(n) {return _get(sprintf("type=%d", n))}
function type_last() {return type_get(type_count())}

function has_save(str,    _type, _n, _x) {
	_type = type_last()
	_x = sprintf("has.count=%s", _type)
	_set(_x, (_n = _get(_x)+1))
	_x = sprintf("has.%d=%s", _n, _type)
	_set(_x, str)
}
function has_count(type) {return _get(sprintf("has.count=%s", type))}
function has_get(type, n) {return _get(sprintf("has.%d=%s", n, type))}
# </data>

function tag_structs() {return ("structs-" prefix_get())}
function tag_open(tag) {print sprintf("# <%s>", tag)}
function tag_close(tag) {print sprintf("# <\\%s>", tag)}
function make_fnm(str,    _pref) {return (prefix_get() "_" str)}
function make_dbnm() {return sprintf("_STRUCTS_%s_db", prefix_get())}

function gen_base(    _fname, _db_nm) {
	tag_open("private")
	_db_nm = make_dbnm()

	_fname = ("_" make_fnm("set"))
	print sprintf("function %s(k, v) {%s[k] = v}", _fname, _db_nm)

	_fname = ("_" make_fnm("get"))
	print sprintf("function %s(k) {return %s[k]}", _fname, _db_nm)

	_fname = ("_" make_fnm("type_chk"))
	print sprintf("function %s(ent, texp) {", _fname)
	print sprintf("\tif (%s(ent) == texp)\n\t\treturn", make_fnm("type_of"))
	print sprintf("\t%s_errq(sprintf(\"entity '%%s' expected type '%%s', actual type '%%s'\", ent, texp, %s(ent)))", prefix_get(), make_fnm("type_of"))
	print "}"
	tag_close("private")

	print ""

	_fname = make_fnm("clear")
	print sprintf("function %s() {delete %s}", _fname, _db_nm)

	_fname = make_fnm("is")
	print sprintf("function %s(ent) {return (ent in %s)}", _fname, _db_nm)

	_fname = make_fnm("type_of")
	print sprintf("function %s(ent) {", _fname)
	print sprintf("\tif (ent in %s)\n\t\treturn %s[ent]", _db_nm, _db_nm)
	print sprintf("\t%s_errq(sprintf(\"'%%s' not an entity\", ent))", prefix_get())
	print "}"

	_fname = make_fnm("new")
	print sprintf("function %s(type,    _ent) {", _fname)
	print sprintf("\t_%s(\"ents\", (_ent = _%s(\"ents\")+1))", make_fnm("set"), make_fnm("get"))
	print "\t_ent = (\"_n\" _ent)"
	print sprintf("\t_%s(_ent, type)", make_fnm("set"))
	print "\treturn _ent"
	print "}"
}

function gen_type(type,    _i, _end, _memb, _pref) {
	_pref = prefix_get()
	_end = has_count(type)
	printf("function %s_make(", make_fnm(type))
	for (_i = 1; _i <= _end; ++_i)
		printf("%s, ", has_get(type, _i))
	print "   _ent) {"
	print sprintf("\t_ent = %s(\"%s\")", make_fnm("new"), type)
	for (_i = 1; _i <= _end; ++_i) {
		_memb = has_get(type, _i)
		print sprintf("\t%s_%s_set_%s(_ent, %s)", _pref, type, _memb, _memb)
	}
	print "\treturn _ent"
	print "}"
	print ""

	for (_i = 1; _i <= _end; ++_i) {
		_memb = has_get(type, _i)
		print sprintf("function %s_%s_set_%s(ent, %s) {", _pref, type, _memb, _memb)
		print sprintf("\t_%s(ent, \"%s\")", make_fnm("type_chk"), type)
		print sprintf("\t_%s((\"%s=\" ent), %s)", make_fnm("set"), _memb, _memb)
		print "}"
		print sprintf("function %s_%s_get_%s(ent) {", _pref, type, _memb)
		print sprintf("\t_%s(ent, \"%s\")", make_fnm("type_chk"), type)
		print sprintf("\treturn _%s((\"%s=\" ent))", make_fnm("get"), _memb)
		print "}"
		print ""
	}
}

function gen_types(    _i, _end, _type) {
	_end = type_count()
	for (_i = 1; _i <= _end; ++_i) {
		_type = type_get(_i)
		tag_open(sprintf("type-%s", _type))
		print sprintf("function %s() {return \"%s\"}", toupper(make_fnm(_type)), _type)
		print ""
		gen_type(_type)
		tag_close(sprintf("type-%s", _type))
	}
}

function generate() {
	gen_base()
	tag_open("types")
	gen_types()
	tag_close("types")
}
# </generate>
# <doc>
function print_help() {
print sprintf("%s %s - type compiler", SCRIPT_NAME(), SCRIPT_VERSION())
print ""
print use_str()
print ""
print "Compiles type descriptions into a type system in awk. 'Compiles in awk'"
print "means it generates awk source code for setters/getters for each type's"
print "members, along with facilities to create an entity of a certain type, check"
print "its type, and a table to remember what values all type variables have. For"
print "an example use the following as an input file:"
print ""
print "start"
print "type btree"
print "has left"
print "has right"
print "end"
print ""
print "Options:"
print "-vFsm=1     - print the fsm 'grammar'"
print "-vVersion=1 - version information"
print "-vHelp=1    - this screen"
exit_success()
}
function print_fsm() {
	print DESCRIPT_FSM()
	exit_success()
}
function print_version() {
print sprintf("%s %s", SCRIPT_NAME(), SCRIPT_VERSION())
exit_success()
}
function use_str() {return sprintf("Use: %s <structs-file>", SCRIPT_NAME())}
function print_use_try() {
pstderr(use_str())
pstderr(sprintf("Try: %s -vHelp=1", SCRIPT_NAME()))
exit_failure()
}
# </doc>
